{"version":3,"sources":["../src/internal.ts","../src/constants.ts","../src/createRedirect.ts","../src/util/shared.ts","../src/util/mergePreDefinedOptions.ts","../src/errors.ts","../src/runtime.ts","../src/util/rfc4648.ts","../src/jwt/algorithms.ts","../src/jwt/assertions.ts","../src/jwt/cryptoKeys.ts","../src/jwt/verifyJwt.ts","../src/util/optionsAssertions.ts","../src/tokens/authenticateContext.ts","../src/tokens/authObjects.ts","../src/util/path.ts","../src/api/endpoints/AbstractApi.ts","../src/api/endpoints/ActorTokenApi.ts","../src/api/endpoints/AccountlessApplicationsAPI.ts","../src/api/endpoints/AllowlistIdentifierApi.ts","../src/api/endpoints/BetaFeaturesApi.ts","../src/api/endpoints/BlocklistIdentifierApi.ts","../src/api/endpoints/ClientApi.ts","../src/api/endpoints/DomainApi.ts","../src/api/endpoints/EmailAddressApi.ts","../src/api/endpoints/InstanceApi.ts","../src/api/endpoints/InvitationApi.ts","../src/api/endpoints/JwksApi.ts","../src/api/endpoints/JwtTemplatesApi.ts","../src/api/endpoints/OrganizationApi.ts","../src/api/endpoints/OAuthApplicationsApi.ts","../src/api/endpoints/PhoneNumberApi.ts","../src/api/endpoints/ProxyCheckApi.ts","../src/api/endpoints/RedirectUrlApi.ts","../src/api/endpoints/SamlConnectionApi.ts","../src/api/endpoints/SessionApi.ts","../src/api/endpoints/SignInTokenApi.ts","../src/api/endpoints/SignUpApi.ts","../src/api/endpoints/TestingTokenApi.ts","../src/api/endpoints/UserApi.ts","../src/api/endpoints/WaitlistEntryApi.ts","../src/api/endpoints/WebhookApi.ts","../src/api/request.ts","../src/api/resources/ActorToken.ts","../src/api/resources/AccountlessApplication.ts","../src/api/resources/AllowlistIdentifier.ts","../src/api/resources/BlocklistIdentifier.ts","../src/api/resources/Session.ts","../src/api/resources/Client.ts","../src/api/resources/CnameTarget.ts","../src/api/resources/Cookies.ts","../src/api/resources/DeletedObject.ts","../src/api/resources/Domain.ts","../src/api/resources/Email.ts","../src/api/resources/IdentificationLink.ts","../src/api/resources/Verification.ts","../src/api/resources/EmailAddress.ts","../src/api/resources/ExternalAccount.ts","../src/api/resources/Instance.ts","../src/api/resources/InstanceRestrictions.ts","../src/api/resources/InstanceSettings.ts","../src/api/resources/Invitation.ts","../src/api/resources/JSON.ts","../src/api/resources/JwtTemplate.ts","../src/api/resources/OauthAccessToken.ts","../src/api/resources/OAuthApplication.ts","../src/api/resources/Organization.ts","../src/api/resources/OrganizationInvitation.ts","../src/api/resources/OrganizationMembership.ts","../src/api/resources/OrganizationSettings.ts","../src/api/resources/PhoneNumber.ts","../src/api/resources/ProxyCheck.ts","../src/api/resources/RedirectUrl.ts","../src/api/resources/SignInTokens.ts","../src/api/resources/SignUpAttempt.ts","../src/api/resources/SMSMessage.ts","../src/api/resources/Token.ts","../src/api/resources/SamlConnection.ts","../src/api/resources/SamlAccount.ts","../src/api/resources/Web3Wallet.ts","../src/api/resources/User.ts","../src/api/resources/WaitlistEntry.ts","../src/api/resources/Deserializer.ts","../src/api/factory.ts","../src/tokens/authStatus.ts","../src/tokens/clerkRequest.ts","../src/tokens/clerkUrl.ts","../src/tokens/cookie.ts","../src/tokens/keys.ts","../src/tokens/verify.ts","../src/tokens/handshake.ts","../src/tokens/organizationMatcher.ts","../src/tokens/request.ts","../src/tokens/factory.ts","../src/util/decorateObjectWithResources.ts"],"sourcesContent":["export { constants } from './constants';\nexport { createRedirect } from './createRedirect';\nexport type { RedirectFun } from './createRedirect';\n\nexport type { CreateAuthenticateRequestOptions } from './tokens/factory';\nexport { createAuthenticateRequest } from './tokens/factory';\n\nexport { debugRequestState } from './tokens/request';\n\nexport type { AuthenticateRequestOptions, OrganizationSyncOptions } from './tokens/types';\n\nexport type { SignedInAuthObjectOptions, SignedInAuthObject, SignedOutAuthObject } from './tokens/authObjects';\nexport { makeAuthObjectSerializable, signedOutAuthObject, signedInAuthObject } from './tokens/authObjects';\n\nexport { AuthStatus } from './tokens/authStatus';\nexport type { RequestState, SignedInState, SignedOutState } from './tokens/authStatus';\n\nexport { decorateObjectWithResources, stripPrivateDataFromObject } from './util/decorateObjectWithResources';\n\nexport { createClerkRequest } from './tokens/clerkRequest';\nexport type { ClerkRequest } from './tokens/clerkRequest';\n\nexport { reverificationError, reverificationErrorResponse } from '@clerk/shared/authorization-errors';\n","export const API_URL = 'https://api.clerk.com';\nexport const API_VERSION = 'v1';\n\nexport const USER_AGENT = `${PACKAGE_NAME}@${PACKAGE_VERSION}`;\nexport const MAX_CACHE_LAST_UPDATED_AT_SECONDS = 5 * 60;\nexport const SUPPORTED_BAPI_VERSION = '2025-04-10';\n\nconst Attributes = {\n  AuthToken: '__clerkAuthToken',\n  AuthSignature: '__clerkAuthSignature',\n  AuthStatus: '__clerkAuthStatus',\n  AuthReason: '__clerkAuthReason',\n  AuthMessage: '__clerkAuthMessage',\n  ClerkUrl: '__clerkUrl',\n} as const;\n\nconst Cookies = {\n  Session: '__session',\n  Refresh: '__refresh',\n  ClientUat: '__client_uat',\n  Handshake: '__clerk_handshake',\n  DevBrowser: '__clerk_db_jwt',\n  RedirectCount: '__clerk_redirect_count',\n  HandshakeNonce: '__clerk_handshake_nonce',\n} as const;\n\nconst QueryParameters = {\n  ClerkSynced: '__clerk_synced',\n  SuffixedCookies: 'suffixed_cookies',\n  ClerkRedirectUrl: '__clerk_redirect_url',\n  // use the reference to Cookies to indicate that it's the same value\n  DevBrowser: Cookies.DevBrowser,\n  Handshake: Cookies.Handshake,\n  HandshakeHelp: '__clerk_help',\n  LegacyDevBrowser: '__dev_session',\n  HandshakeReason: '__clerk_hs_reason',\n  HandshakeNonce: Cookies.HandshakeNonce,\n} as const;\n\nconst Headers = {\n  Accept: 'accept',\n  AuthMessage: 'x-clerk-auth-message',\n  Authorization: 'authorization',\n  AuthReason: 'x-clerk-auth-reason',\n  AuthSignature: 'x-clerk-auth-signature',\n  AuthStatus: 'x-clerk-auth-status',\n  AuthToken: 'x-clerk-auth-token',\n  CacheControl: 'cache-control',\n  ClerkRedirectTo: 'x-clerk-redirect-to',\n  ClerkRequestData: 'x-clerk-request-data',\n  ClerkUrl: 'x-clerk-clerk-url',\n  CloudFrontForwardedProto: 'cloudfront-forwarded-proto',\n  ContentType: 'content-type',\n  ContentSecurityPolicy: 'content-security-policy',\n  ContentSecurityPolicyReportOnly: 'content-security-policy-report-only',\n  EnableDebug: 'x-clerk-debug',\n  ForwardedHost: 'x-forwarded-host',\n  ForwardedPort: 'x-forwarded-port',\n  ForwardedProto: 'x-forwarded-proto',\n  Host: 'host',\n  Location: 'location',\n  Nonce: 'x-nonce',\n  Origin: 'origin',\n  Referrer: 'referer',\n  SecFetchDest: 'sec-fetch-dest',\n  UserAgent: 'user-agent',\n  ReportingEndpoints: 'reporting-endpoints',\n} as const;\n\nconst ContentTypes = {\n  Json: 'application/json',\n} as const;\n\n/**\n * @internal\n */\nexport const constants = {\n  Attributes,\n  Cookies,\n  Headers,\n  ContentTypes,\n  QueryParameters,\n} as const;\n\nexport type Constants = typeof constants;\n","import { buildAccountsBaseUrl } from '@clerk/shared/buildAccountsBaseUrl';\nimport type { SessionStatusClaim } from '@clerk/types';\n\nimport { constants } from './constants';\nimport { errorThrower, parsePublishableKey } from './util/shared';\n\nconst buildUrl = (\n  _baseUrl: string | URL,\n  _targetUrl: string | URL,\n  _returnBackUrl?: string | URL | null,\n  _devBrowserToken?: string | null,\n) => {\n  if (_baseUrl === '') {\n    return legacyBuildUrl(_targetUrl.toString(), _returnBackUrl?.toString());\n  }\n\n  const baseUrl = new URL(_baseUrl);\n  const returnBackUrl = _returnBackUrl ? new URL(_returnBackUrl, baseUrl) : undefined;\n  const res = new URL(_targetUrl, baseUrl);\n\n  if (returnBackUrl) {\n    res.searchParams.set('redirect_url', returnBackUrl.toString());\n  }\n  // For cross-origin redirects, we need to pass the dev browser token for URL session syncing\n  if (_devBrowserToken && baseUrl.hostname !== res.hostname) {\n    res.searchParams.set(constants.QueryParameters.DevBrowser, _devBrowserToken);\n  }\n  return res.toString();\n};\n\n/**\n * In v5, we deprecated the top-level redirectToSignIn and redirectToSignUp functions\n * in favor of the new auth().redirectToSignIn helpers\n * In order to allow for a smooth transition, we need to support the legacy redirectToSignIn for now\n * as we will remove it in v6.\n * In order to make sure that the legacy function works as expected, we will use legacyBuildUrl\n * to build the url if baseUrl is not provided (which is the case for legacy redirectToSignIn)\n * This function can be safely removed when we remove the legacy redirectToSignIn function\n */\nconst legacyBuildUrl = (targetUrl: string, redirectUrl?: string) => {\n  let url;\n  if (!targetUrl.startsWith('http')) {\n    if (!redirectUrl || !redirectUrl.startsWith('http')) {\n      throw new Error('destination url or return back url should be an absolute path url!');\n    }\n\n    const baseURL = new URL(redirectUrl);\n    url = new URL(targetUrl, baseURL.origin);\n  } else {\n    url = new URL(targetUrl);\n  }\n\n  if (redirectUrl) {\n    url.searchParams.set('redirect_url', redirectUrl);\n  }\n\n  return url.toString();\n};\n\ntype RedirectAdapter<RedirectReturn> = (url: string) => RedirectReturn;\ntype RedirectToParams = { returnBackUrl?: string | URL | null };\nexport type RedirectFun<ReturnType> = (params?: RedirectToParams) => ReturnType;\n\n/**\n * @internal\n */\ntype CreateRedirect = <ReturnType>(params: {\n  publishableKey: string;\n  devBrowserToken?: string;\n  redirectAdapter: RedirectAdapter<ReturnType>;\n  baseUrl: URL | string;\n  signInUrl?: URL | string;\n  signUpUrl?: URL | string;\n  sessionStatus?: SessionStatusClaim | null;\n}) => {\n  redirectToSignIn: RedirectFun<ReturnType>;\n  redirectToSignUp: RedirectFun<ReturnType>;\n};\n\nexport const createRedirect: CreateRedirect = params => {\n  const { publishableKey, redirectAdapter, signInUrl, signUpUrl, baseUrl, sessionStatus } = params;\n  const parsedPublishableKey = parsePublishableKey(publishableKey);\n  const frontendApi = parsedPublishableKey?.frontendApi;\n  const isDevelopment = parsedPublishableKey?.instanceType === 'development';\n  const accountsBaseUrl = buildAccountsBaseUrl(frontendApi);\n  const hasPendingStatus = sessionStatus === 'pending';\n\n  const redirectToTasks = (url: string | URL, { returnBackUrl }: RedirectToParams) => {\n    return redirectAdapter(\n      buildUrl(baseUrl, `${url}/tasks`, returnBackUrl, isDevelopment ? params.devBrowserToken : null),\n    );\n  };\n\n  const redirectToSignUp = ({ returnBackUrl }: RedirectToParams = {}) => {\n    if (!signUpUrl && !accountsBaseUrl) {\n      errorThrower.throwMissingPublishableKeyError();\n    }\n\n    const accountsSignUpUrl = `${accountsBaseUrl}/sign-up`;\n\n    // Allows redirection to SignInOrUp path\n    function buildSignUpUrl(signIn: string | URL | undefined) {\n      if (!signIn) {\n        return;\n      }\n      const url = new URL(signIn, baseUrl);\n      url.pathname = `${url.pathname}/create`;\n      return url.toString();\n    }\n\n    const targetUrl = signUpUrl || buildSignUpUrl(signInUrl) || accountsSignUpUrl;\n\n    if (hasPendingStatus) {\n      return redirectToTasks(targetUrl, { returnBackUrl });\n    }\n\n    return redirectAdapter(buildUrl(baseUrl, targetUrl, returnBackUrl, isDevelopment ? params.devBrowserToken : null));\n  };\n\n  const redirectToSignIn = ({ returnBackUrl }: RedirectToParams = {}) => {\n    if (!signInUrl && !accountsBaseUrl) {\n      errorThrower.throwMissingPublishableKeyError();\n    }\n\n    const accountsSignInUrl = `${accountsBaseUrl}/sign-in`;\n    const targetUrl = signInUrl || accountsSignInUrl;\n\n    if (hasPendingStatus) {\n      return redirectToTasks(targetUrl, { returnBackUrl });\n    }\n\n    return redirectAdapter(buildUrl(baseUrl, targetUrl, returnBackUrl, isDevelopment ? params.devBrowserToken : null));\n  };\n\n  return { redirectToSignUp, redirectToSignIn };\n};\n","export { addClerkPrefix, getScriptUrl, getClerkJsMajorVersionOrTag } from '@clerk/shared/url';\nexport { retry } from '@clerk/shared/retry';\nexport {\n  isDevelopmentFromSecretKey,\n  isProductionFromSecretKey,\n  parsePublishableKey,\n  getCookieSuffix,\n  getSuffixedCookieName,\n} from '@clerk/shared/keys';\nexport { deprecated, deprecatedProperty } from '@clerk/shared/deprecated';\n\nimport { buildErrorThrower } from '@clerk/shared/error';\nimport { createDevOrStagingUrlCache } from '@clerk/shared/keys';\n// TODO: replace packageName with `${PACKAGE_NAME}@${PACKAGE_VERSION}` from tsup.config.ts\nexport const errorThrower = buildErrorThrower({ packageName: '@clerk/backend' });\n\nexport const { isDevOrStagingUrl } = createDevOrStagingUrlCache();\n","export function mergePreDefinedOptions<T extends Record<string, any>>(preDefinedOptions: T, options: Partial<T>): T {\n  return Object.keys(preDefinedOptions).reduce(\n    (obj: T, key: string) => {\n      return { ...obj, [key]: options[key] || obj[key] };\n    },\n    { ...preDefinedOptions },\n  );\n}\n","export type TokenCarrier = 'header' | 'cookie';\n\nexport const TokenVerificationErrorCode = {\n  InvalidSecretKey: 'clerk_key_invalid',\n};\n\nexport type TokenVerificationErrorCode = (typeof TokenVerificationErrorCode)[keyof typeof TokenVerificationErrorCode];\n\nexport const TokenVerificationErrorReason = {\n  TokenExpired: 'token-expired',\n  TokenInvalid: 'token-invalid',\n  TokenInvalidAlgorithm: 'token-invalid-algorithm',\n  TokenInvalidAuthorizedParties: 'token-invalid-authorized-parties',\n  TokenInvalidSignature: 'token-invalid-signature',\n  TokenNotActiveYet: 'token-not-active-yet',\n  TokenIatInTheFuture: 'token-iat-in-the-future',\n  TokenVerificationFailed: 'token-verification-failed',\n  InvalidSecretKey: 'secret-key-invalid',\n  LocalJWKMissing: 'jwk-local-missing',\n  RemoteJWKFailedToLoad: 'jwk-remote-failed-to-load',\n  RemoteJWKInvalid: 'jwk-remote-invalid',\n  RemoteJWKMissing: 'jwk-remote-missing',\n  JWKFailedToResolve: 'jwk-failed-to-resolve',\n  JWKKidMismatch: 'jwk-kid-mismatch',\n};\n\nexport type TokenVerificationErrorReason =\n  (typeof TokenVerificationErrorReason)[keyof typeof TokenVerificationErrorReason];\n\nexport const TokenVerificationErrorAction = {\n  ContactSupport: 'Contact support@clerk.com',\n  EnsureClerkJWT: 'Make sure that this is a valid Clerk generate JWT.',\n  SetClerkJWTKey: 'Set the CLERK_JWT_KEY environment variable.',\n  SetClerkSecretKey: 'Set the CLERK_SECRET_KEY environment variable.',\n  EnsureClockSync: 'Make sure your system clock is in sync (e.g. turn off and on automatic time synchronization).',\n};\n\nexport type TokenVerificationErrorAction =\n  (typeof TokenVerificationErrorAction)[keyof typeof TokenVerificationErrorAction];\n\nexport class TokenVerificationError extends Error {\n  action?: TokenVerificationErrorAction;\n  reason: TokenVerificationErrorReason;\n  tokenCarrier?: TokenCarrier;\n\n  constructor({\n    action,\n    message,\n    reason,\n  }: {\n    action?: TokenVerificationErrorAction;\n    message: string;\n    reason: TokenVerificationErrorReason;\n  }) {\n    super(message);\n\n    Object.setPrototypeOf(this, TokenVerificationError.prototype);\n\n    this.reason = reason;\n    this.message = message;\n    this.action = action;\n  }\n\n  public getFullMessage() {\n    return `${[this.message, this.action].filter(m => m).join(' ')} (reason=${this.reason}, token-carrier=${\n      this.tokenCarrier\n    })`;\n  }\n}\n\nexport class SignJWTError extends Error {}\n","/**\n * This file exports APIs that vary across runtimes (i.e. Node & Browser - V8 isolates)\n * as a singleton object.\n *\n * Runtime polyfills are written in VanillaJS for now to avoid TS complication. Moreover,\n * due to this issue https://github.com/microsoft/TypeScript/issues/44848, there is not a good way\n * to tell Typescript which conditional import to use during build type.\n *\n * The Runtime type definition ensures type safety for now.\n * Runtime js modules are copied into dist folder with bash script.\n *\n * TODO: Support TS runtime modules\n */\n\n// @ts-ignore - These are package subpaths\nimport { webcrypto as crypto } from '#crypto';\n\ntype Runtime = {\n  crypto: Crypto;\n  fetch: typeof globalThis.fetch;\n  AbortController: typeof globalThis.AbortController;\n  Blob: typeof globalThis.Blob;\n  FormData: typeof globalThis.FormData;\n  Headers: typeof globalThis.Headers;\n  Request: typeof globalThis.Request;\n  Response: typeof globalThis.Response;\n};\n\n// Invoking the global.fetch without binding it first to the globalObject fails in\n// Cloudflare Workers with an \"Illegal Invocation\" error.\n//\n// The globalThis object is supported for Node >= 12.0.\n//\n// https://github.com/supabase/supabase/issues/4417\nconst globalFetch = fetch.bind(globalThis);\n\nexport const runtime: Runtime = {\n  crypto,\n  get fetch() {\n    // We need to use the globalFetch for Cloudflare Workers but the fetch for testing\n    return process.env.NODE_ENV === 'test' ? fetch : globalFetch;\n  },\n  AbortController: globalThis.AbortController,\n  Blob: globalThis.Blob,\n  FormData: globalThis.FormData,\n  Headers: globalThis.Headers,\n  Request: globalThis.Request,\n  Response: globalThis.Response,\n};\n","/**\n * The base64url helper was extracted from the rfc4648 package\n * in order to resolve CSJ/ESM interoperability issues\n *\n * https://github.com/swansontec/rfc4648.js\n *\n * For more context please refer to:\n * - https://github.com/evanw/esbuild/issues/1719\n * - https://github.com/evanw/esbuild/issues/532\n * - https://github.com/swansontec/rollup-plugin-mjs-entry\n */\nexport const base64url = {\n  parse(string: string, opts?: ParseOptions): Uint8Array {\n    return parse(string, base64UrlEncoding, opts);\n  },\n\n  stringify(data: ArrayLike<number>, opts?: StringifyOptions): string {\n    return stringify(data, base64UrlEncoding, opts);\n  },\n};\n\nconst base64UrlEncoding: Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bits: 6,\n};\n\ninterface Encoding {\n  bits: number;\n  chars: string;\n  codes?: { [char: string]: number };\n}\n\ninterface ParseOptions {\n  loose?: boolean;\n  out?: new (size: number) => { [index: number]: number };\n}\n\ninterface StringifyOptions {\n  pad?: boolean;\n}\n\nfunction parse(string: string, encoding: Encoding, opts: ParseOptions = {}): Uint8Array {\n  // Build the character lookup table:\n  if (!encoding.codes) {\n    encoding.codes = {};\n    for (let i = 0; i < encoding.chars.length; ++i) {\n      encoding.codes[encoding.chars[i]] = i;\n    }\n  }\n\n  // The string must have a whole number of bytes:\n  if (!opts.loose && (string.length * encoding.bits) & 7) {\n    throw new SyntaxError('Invalid padding');\n  }\n\n  // Count the padding bytes:\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n\n    // If we get a whole number of bytes, there is too much padding:\n    if (!opts.loose && !(((string.length - end) * encoding.bits) & 7)) {\n      throw new SyntaxError('Invalid padding');\n    }\n  }\n\n  // Allocate the output:\n  const out = new (opts.out ?? Uint8Array)(((end * encoding.bits) / 8) | 0) as Uint8Array;\n\n  // Parse the data:\n  let bits = 0; // Number of bits currently in the buffer\n  let buffer = 0; // Bits waiting to be written out, MSB first\n  let written = 0; // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = encoding.codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[i]);\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << encoding.bits) | value;\n    bits += encoding.bits;\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & (buffer >> bits);\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= encoding.bits || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n}\n\nfunction stringify(data: ArrayLike<number>, encoding: Encoding, opts: StringifyOptions = {}): string {\n  const { pad = true } = opts;\n  const mask = (1 << encoding.bits) - 1;\n  let out = '';\n\n  let bits = 0; // Number of bits currently in the buffer\n  let buffer = 0; // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | (0xff & data[i]);\n    bits += 8;\n\n    // Write out as much as we can:\n    while (bits > encoding.bits) {\n      bits -= encoding.bits;\n      out += encoding.chars[mask & (buffer >> bits)];\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += encoding.chars[mask & (buffer << (encoding.bits - bits))];\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * encoding.bits) & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n}\n","const algToHash: Record<string, string> = {\n  RS256: 'SHA-256',\n  RS384: 'SHA-384',\n  RS512: 'SHA-512',\n};\nconst RSA_ALGORITHM_NAME = 'RSASSA-PKCS1-v1_5';\n\nconst jwksAlgToCryptoAlg: Record<string, string> = {\n  RS256: RSA_ALGORITHM_NAME,\n  RS384: RSA_ALGORITHM_NAME,\n  RS512: RSA_ALGORITHM_NAME,\n};\n\nexport const algs = Object.keys(algToHash);\n\nexport function getCryptoAlgorithm(algorithmName: string): RsaHashedImportParams {\n  const hash = algToHash[algorithmName];\n  const name = jwksAlgToCryptoAlg[algorithmName];\n\n  if (!hash || !name) {\n    throw new Error(`Unsupported algorithm ${algorithmName}, expected one of ${algs.join(',')}.`);\n  }\n\n  return {\n    hash: { name: algToHash[algorithmName] },\n    name: jwksAlgToCryptoAlg[algorithmName],\n  };\n}\n","import { TokenVerificationError, TokenVerificationErrorAction, TokenVerificationErrorReason } from '../errors';\nimport { algs } from './algorithms';\n\nexport type IssuerResolver = string | ((iss: string) => boolean);\n\nconst isArrayString = (s: unknown): s is string[] => {\n  return Array.isArray(s) && s.length > 0 && s.every(a => typeof a === 'string');\n};\n\nexport const assertAudienceClaim = (aud?: unknown, audience?: unknown) => {\n  const audienceList = [audience].flat().filter(a => !!a);\n  const audList = [aud].flat().filter(a => !!a);\n  const shouldVerifyAudience = audienceList.length > 0 && audList.length > 0;\n\n  if (!shouldVerifyAudience) {\n    // Notice: Clerk JWTs use AZP claim instead of Audience\n    //\n    // return {\n    //   valid: false,\n    //   reason: `Invalid JWT audience claim (aud) ${JSON.stringify(\n    //     aud,\n    //   )}. Expected a string or a non-empty array of strings.`,\n    // };\n    return;\n  }\n\n  if (typeof aud === 'string') {\n    if (!audienceList.includes(aud)) {\n      throw new TokenVerificationError({\n        action: TokenVerificationErrorAction.EnsureClerkJWT,\n        reason: TokenVerificationErrorReason.TokenVerificationFailed,\n        message: `Invalid JWT audience claim (aud) ${JSON.stringify(aud)}. Is not included in \"${JSON.stringify(\n          audienceList,\n        )}\".`,\n      });\n    }\n  } else if (isArrayString(aud)) {\n    if (!aud.some(a => audienceList.includes(a))) {\n      throw new TokenVerificationError({\n        action: TokenVerificationErrorAction.EnsureClerkJWT,\n        reason: TokenVerificationErrorReason.TokenVerificationFailed,\n        message: `Invalid JWT audience claim array (aud) ${JSON.stringify(aud)}. Is not included in \"${JSON.stringify(\n          audienceList,\n        )}\".`,\n      });\n    }\n  }\n};\n\nexport const assertHeaderType = (typ?: unknown) => {\n  if (typeof typ === 'undefined') {\n    return;\n  }\n\n  if (typ !== 'JWT') {\n    throw new TokenVerificationError({\n      action: TokenVerificationErrorAction.EnsureClerkJWT,\n      reason: TokenVerificationErrorReason.TokenInvalid,\n      message: `Invalid JWT type ${JSON.stringify(typ)}. Expected \"JWT\".`,\n    });\n  }\n};\n\nexport const assertHeaderAlgorithm = (alg: string) => {\n  if (!algs.includes(alg)) {\n    throw new TokenVerificationError({\n      action: TokenVerificationErrorAction.EnsureClerkJWT,\n      reason: TokenVerificationErrorReason.TokenInvalidAlgorithm,\n      message: `Invalid JWT algorithm ${JSON.stringify(alg)}. Supported: ${algs}.`,\n    });\n  }\n};\n\nexport const assertSubClaim = (sub?: string) => {\n  if (typeof sub !== 'string') {\n    throw new TokenVerificationError({\n      action: TokenVerificationErrorAction.EnsureClerkJWT,\n      reason: TokenVerificationErrorReason.TokenVerificationFailed,\n      message: `Subject claim (sub) is required and must be a string. Received ${JSON.stringify(sub)}.`,\n    });\n  }\n};\n\nexport const assertAuthorizedPartiesClaim = (azp?: string, authorizedParties?: string[]) => {\n  if (!azp || !authorizedParties || authorizedParties.length === 0) {\n    return;\n  }\n\n  if (!authorizedParties.includes(azp)) {\n    throw new TokenVerificationError({\n      reason: TokenVerificationErrorReason.TokenInvalidAuthorizedParties,\n      message: `Invalid JWT Authorized party claim (azp) ${JSON.stringify(azp)}. Expected \"${authorizedParties}\".`,\n    });\n  }\n};\n\nexport const assertExpirationClaim = (exp: number, clockSkewInMs: number) => {\n  if (typeof exp !== 'number') {\n    throw new TokenVerificationError({\n      action: TokenVerificationErrorAction.EnsureClerkJWT,\n      reason: TokenVerificationErrorReason.TokenVerificationFailed,\n      message: `Invalid JWT expiry date claim (exp) ${JSON.stringify(exp)}. Expected number.`,\n    });\n  }\n\n  const currentDate = new Date(Date.now());\n  const expiryDate = new Date(0);\n  expiryDate.setUTCSeconds(exp);\n\n  const expired = expiryDate.getTime() <= currentDate.getTime() - clockSkewInMs;\n  if (expired) {\n    throw new TokenVerificationError({\n      reason: TokenVerificationErrorReason.TokenExpired,\n      message: `JWT is expired. Expiry date: ${expiryDate.toUTCString()}, Current date: ${currentDate.toUTCString()}.`,\n    });\n  }\n};\n\nexport const assertActivationClaim = (nbf: number | undefined, clockSkewInMs: number) => {\n  if (typeof nbf === 'undefined') {\n    return;\n  }\n\n  if (typeof nbf !== 'number') {\n    throw new TokenVerificationError({\n      action: TokenVerificationErrorAction.EnsureClerkJWT,\n      reason: TokenVerificationErrorReason.TokenVerificationFailed,\n      message: `Invalid JWT not before date claim (nbf) ${JSON.stringify(nbf)}. Expected number.`,\n    });\n  }\n\n  const currentDate = new Date(Date.now());\n  const notBeforeDate = new Date(0);\n  notBeforeDate.setUTCSeconds(nbf);\n\n  const early = notBeforeDate.getTime() > currentDate.getTime() + clockSkewInMs;\n  if (early) {\n    throw new TokenVerificationError({\n      reason: TokenVerificationErrorReason.TokenNotActiveYet,\n      message: `JWT cannot be used prior to not before date claim (nbf). Not before date: ${notBeforeDate.toUTCString()}; Current date: ${currentDate.toUTCString()};`,\n    });\n  }\n};\n\nexport const assertIssuedAtClaim = (iat: number | undefined, clockSkewInMs: number) => {\n  if (typeof iat === 'undefined') {\n    return;\n  }\n\n  if (typeof iat !== 'number') {\n    throw new TokenVerificationError({\n      action: TokenVerificationErrorAction.EnsureClerkJWT,\n      reason: TokenVerificationErrorReason.TokenVerificationFailed,\n      message: `Invalid JWT issued at date claim (iat) ${JSON.stringify(iat)}. Expected number.`,\n    });\n  }\n\n  const currentDate = new Date(Date.now());\n  const issuedAtDate = new Date(0);\n  issuedAtDate.setUTCSeconds(iat);\n\n  const postIssued = issuedAtDate.getTime() > currentDate.getTime() + clockSkewInMs;\n  if (postIssued) {\n    throw new TokenVerificationError({\n      reason: TokenVerificationErrorReason.TokenIatInTheFuture,\n      message: `JWT issued at date claim (iat) is in the future. Issued at date: ${issuedAtDate.toUTCString()}; Current date: ${currentDate.toUTCString()};`,\n    });\n  }\n};\n","import { isomorphicAtob } from '@clerk/shared/isomorphicAtob';\n\nimport { runtime } from '../runtime';\n\n// https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#pkcs_8_import\nfunction pemToBuffer(secret: string): ArrayBuffer {\n  const trimmed = secret\n    .replace(/-----BEGIN.*?-----/g, '')\n    .replace(/-----END.*?-----/g, '')\n    .replace(/\\s/g, '');\n\n  const decoded = isomorphicAtob(trimmed);\n\n  const buffer = new ArrayBuffer(decoded.length);\n  const bufView = new Uint8Array(buffer);\n\n  for (let i = 0, strLen = decoded.length; i < strLen; i++) {\n    bufView[i] = decoded.charCodeAt(i);\n  }\n\n  return bufView;\n}\n\nexport function importKey(\n  key: JsonWebKey | string,\n  algorithm: RsaHashedImportParams,\n  keyUsage: 'verify' | 'sign',\n): Promise<CryptoKey> {\n  if (typeof key === 'object') {\n    return runtime.crypto.subtle.importKey('jwk', key, algorithm, false, [keyUsage]);\n  }\n\n  const keyData = pemToBuffer(key);\n  const format = keyUsage === 'sign' ? 'pkcs8' : 'spki';\n\n  return runtime.crypto.subtle.importKey(format, keyData, algorithm, false, [keyUsage]);\n}\n","import type { Jwt, JwtPayload } from '@clerk/types';\n\nimport { TokenVerificationError, TokenVerificationErrorAction, TokenVerificationErrorReason } from '../errors';\nimport { runtime } from '../runtime';\nimport { base64url } from '../util/rfc4648';\nimport { getCryptoAlgorithm } from './algorithms';\nimport {\n  assertActivationClaim,\n  assertAudienceClaim,\n  assertAuthorizedPartiesClaim,\n  assertExpirationClaim,\n  assertHeaderAlgorithm,\n  assertHeaderType,\n  assertIssuedAtClaim,\n  assertSubClaim,\n} from './assertions';\nimport { importKey } from './cryptoKeys';\nimport type { JwtReturnType } from './types';\n\nconst DEFAULT_CLOCK_SKEW_IN_MS = 5 * 1000;\n\nexport async function hasValidSignature(jwt: Jwt, key: JsonWebKey | string): Promise<JwtReturnType<boolean, Error>> {\n  const { header, signature, raw } = jwt;\n  const encoder = new TextEncoder();\n  const data = encoder.encode([raw.header, raw.payload].join('.'));\n  const algorithm = getCryptoAlgorithm(header.alg);\n\n  try {\n    const cryptoKey = await importKey(key, algorithm, 'verify');\n\n    const verified = await runtime.crypto.subtle.verify(algorithm.name, cryptoKey, signature, data);\n    return { data: verified };\n  } catch (error) {\n    return {\n      errors: [\n        new TokenVerificationError({\n          reason: TokenVerificationErrorReason.TokenInvalidSignature,\n          message: (error as Error)?.message,\n        }),\n      ],\n    };\n  }\n}\n\nexport function decodeJwt(token: string): JwtReturnType<Jwt, TokenVerificationError> {\n  const tokenParts = (token || '').toString().split('.');\n  if (tokenParts.length !== 3) {\n    return {\n      errors: [\n        new TokenVerificationError({\n          reason: TokenVerificationErrorReason.TokenInvalid,\n          message: `Invalid JWT form. A JWT consists of three parts separated by dots.`,\n        }),\n      ],\n    };\n  }\n\n  const [rawHeader, rawPayload, rawSignature] = tokenParts;\n\n  const decoder = new TextDecoder();\n\n  // To verify a JWS with SubtleCrypto you need to be careful to encode and decode\n  // the data properly between binary and base64url representation. Unfortunately\n  // the standard implementation in the V8 of btoa() and atob() are difficult to\n  // work with as they use \"a Unicode string containing only characters in the\n  // range U+0000 to U+00FF, each representing a binary byte with values 0x00 to\n  // 0xFF respectively\" as the representation of binary data.\n\n  // A better solution to represent binary data in Javascript is to use ES6 TypedArray\n  // and use a Javascript library to convert them to base64url that honors RFC 4648.\n\n  // Side note: The difference between base64 and base64url is the characters selected\n  // for value 62 and 63 in the standard, base64 encode them to + and / while base64url\n  // encode - and _.\n\n  // More info at https://stackoverflow.com/questions/54062583/how-to-verify-a-signed-jwt-with-subtlecrypto-of-the-web-crypto-API\n  const header = JSON.parse(decoder.decode(base64url.parse(rawHeader, { loose: true })));\n  const payload = JSON.parse(decoder.decode(base64url.parse(rawPayload, { loose: true })));\n\n  const signature = base64url.parse(rawSignature, { loose: true });\n\n  const data = {\n    header,\n    payload,\n    signature,\n    raw: {\n      header: rawHeader,\n      payload: rawPayload,\n      signature: rawSignature,\n      text: token,\n    },\n  } satisfies Jwt;\n\n  return { data };\n}\n\n/**\n * @inline\n */\nexport type VerifyJwtOptions = {\n  /**\n   * A string or list of [audiences](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.3). If passed, it is checked against the `aud` claim in the token.\n   */\n  audience?: string | string[];\n  /**\n   * An allowlist of origins to verify against, to protect your application from the subdomain cookie leaking attack.\n   * @example\n   * ```ts\n   * ['http://localhost:3000', 'https://example.com']\n   * ```\n   */\n  authorizedParties?: string[];\n  /**\n   * Specifies the allowed time difference (in milliseconds) between the Clerk server (which generates the token) and the clock of the user's application server when validating a token.\n   * @default 5000\n   */\n  clockSkewInMs?: number;\n  /**\n   * @internal\n   */\n  key: JsonWebKey | string;\n};\n\nexport async function verifyJwt(\n  token: string,\n  options: VerifyJwtOptions,\n): Promise<JwtReturnType<JwtPayload, TokenVerificationError>> {\n  const { audience, authorizedParties, clockSkewInMs, key } = options;\n  const clockSkew = clockSkewInMs || DEFAULT_CLOCK_SKEW_IN_MS;\n\n  const { data: decoded, errors } = decodeJwt(token);\n  if (errors) {\n    return { errors };\n  }\n\n  const { header, payload } = decoded;\n  try {\n    // Header verifications\n    const { typ, alg } = header;\n\n    assertHeaderType(typ);\n    assertHeaderAlgorithm(alg);\n\n    // Payload verifications\n    const { azp, sub, aud, iat, exp, nbf } = payload;\n\n    assertSubClaim(sub);\n    assertAudienceClaim([aud], [audience]);\n    assertAuthorizedPartiesClaim(azp, authorizedParties);\n    assertExpirationClaim(exp, clockSkew);\n    assertActivationClaim(nbf, clockSkew);\n    assertIssuedAtClaim(iat, clockSkew);\n  } catch (err) {\n    return { errors: [err as TokenVerificationError] };\n  }\n\n  const { data: signatureValid, errors: signatureErrors } = await hasValidSignature(decoded, key);\n  if (signatureErrors) {\n    return {\n      errors: [\n        new TokenVerificationError({\n          action: TokenVerificationErrorAction.EnsureClerkJWT,\n          reason: TokenVerificationErrorReason.TokenVerificationFailed,\n          message: `Error verifying JWT signature. ${signatureErrors[0]}`,\n        }),\n      ],\n    };\n  }\n\n  if (!signatureValid) {\n    return {\n      errors: [\n        new TokenVerificationError({\n          reason: TokenVerificationErrorReason.TokenInvalidSignature,\n          message: 'JWT signature is invalid.',\n        }),\n      ],\n    };\n  }\n\n  return { data: payload };\n}\n","import { parsePublishableKey } from './shared';\n\nexport function assertValidSecretKey(val: unknown): asserts val is string {\n  if (!val || typeof val !== 'string') {\n    throw Error('Missing Clerk Secret Key. Go to https://dashboard.clerk.com and get your key for your instance.');\n  }\n\n  //TODO: Check if the key is invalid and throw error\n}\n\nexport function assertValidPublishableKey(val: unknown): asserts val is string {\n  parsePublishableKey(val as string | undefined, { fatal: true });\n}\n","import type { Jwt } from '@clerk/types';\n\nimport { constants } from '../constants';\nimport { decodeJwt } from '../jwt/verifyJwt';\nimport { runtime } from '../runtime';\nimport { assertValidPublishableKey } from '../util/optionsAssertions';\nimport { getCookieSuffix, getSuffixedCookieName, parsePublishableKey } from '../util/shared';\nimport type { ClerkRequest } from './clerkRequest';\nimport type { AuthenticateRequestOptions } from './types';\n\ninterface AuthenticateContext extends AuthenticateRequestOptions {\n  // header-based values\n  sessionTokenInHeader: string | undefined;\n  origin: string | undefined;\n  host: string | undefined;\n  forwardedHost: string | undefined;\n  forwardedProto: string | undefined;\n  referrer: string | undefined;\n  userAgent: string | undefined;\n  secFetchDest: string | undefined;\n  accept: string | undefined;\n  // cookie-based values\n  sessionTokenInCookie: string | undefined;\n  refreshTokenInCookie: string | undefined;\n  clientUat: number;\n  // handshake-related values\n  devBrowserToken: string | undefined;\n  handshakeNonce: string | undefined;\n  handshakeToken: string | undefined;\n  handshakeRedirectLoopCounter: number;\n\n  // url derived from headers\n  clerkUrl: URL;\n  // enforce existence of the following props\n  publishableKey: string;\n  instanceType: string;\n  frontendApi: string;\n}\n\n/**\n * All data required to authenticate a request.\n * This is the data we use to decide whether a request\n * is in a signed in or signed out state or if we need\n * to perform a handshake.\n */\nclass AuthenticateContext implements AuthenticateContext {\n  /**\n   * Retrieves the session token from either the cookie or the header.\n   *\n   * @returns {string | undefined} The session token if available, otherwise undefined.\n   */\n  public get sessionToken(): string | undefined {\n    return this.sessionTokenInCookie || this.sessionTokenInHeader;\n  }\n\n  public constructor(\n    private cookieSuffix: string,\n    private clerkRequest: ClerkRequest,\n    options: AuthenticateRequestOptions,\n  ) {\n    // Even though the options are assigned to this later in this function\n    // we set the publishableKey here because it is being used in cookies/headers/handshake-values\n    // as part of getMultipleAppsCookie\n    this.initPublishableKeyValues(options);\n    this.initHeaderValues();\n    // initCookieValues should be used before initHandshakeValues because it depends on suffixedCookies\n    this.initCookieValues();\n    this.initHandshakeValues();\n    Object.assign(this, options);\n    this.clerkUrl = this.clerkRequest.clerkUrl;\n  }\n\n  public usesSuffixedCookies(): boolean {\n    const suffixedClientUat = this.getSuffixedCookie(constants.Cookies.ClientUat);\n    const clientUat = this.getCookie(constants.Cookies.ClientUat);\n    const suffixedSession = this.getSuffixedCookie(constants.Cookies.Session) || '';\n    const session = this.getCookie(constants.Cookies.Session) || '';\n\n    // In the case of malformed session cookies (eg missing the iss claim), we should\n    // use the un-suffixed cookies to return signed-out state instead of triggering\n    // handshake\n    if (session && !this.tokenHasIssuer(session)) {\n      return false;\n    }\n\n    // If there's a token in un-suffixed, and it doesn't belong to this\n    // instance, then we must trust suffixed\n    if (session && !this.tokenBelongsToInstance(session)) {\n      return true;\n    }\n\n    // If there are no suffixed cookies use un-suffixed\n    if (!suffixedClientUat && !suffixedSession) {\n      return false;\n    }\n\n    const { data: sessionData } = decodeJwt(session);\n    const sessionIat = sessionData?.payload.iat || 0;\n    const { data: suffixedSessionData } = decodeJwt(suffixedSession);\n    const suffixedSessionIat = suffixedSessionData?.payload.iat || 0;\n\n    // Both indicate signed in, but un-suffixed is newer\n    // Trust un-suffixed because it's newer\n    if (suffixedClientUat !== '0' && clientUat !== '0' && sessionIat > suffixedSessionIat) {\n      return false;\n    }\n\n    // Suffixed indicates signed out, but un-suffixed indicates signed in\n    // Trust un-suffixed because it gets set with both new and old clerk.js,\n    // so we can assume it's newer\n    if (suffixedClientUat === '0' && clientUat !== '0') {\n      return false;\n    }\n\n    // Suffixed indicates signed in, un-suffixed indicates signed out\n    // This is the tricky one\n\n    // In production, suffixed_uat should be set reliably, since it's\n    // set by FAPI and not clerk.js. So in the scenario where a developer\n    // downgrades, the state will look like this:\n    // - un-suffixed session cookie: empty\n    // - un-suffixed uat: 0\n    // - suffixed session cookie: (possibly filled, possibly empty)\n    // - suffixed uat: 0\n\n    // Our SDK honors client_uat over the session cookie, so we don't\n    // need a special case for production. We can rely on suffixed,\n    // and the fact that the suffixed uat is set properly means and\n    // suffixed session cookie will be ignored.\n\n    // The important thing to make sure we have a test that confirms\n    // the user ends up as signed out in this scenario, and the suffixed\n    // session cookie is ignored\n\n    // In development, suffixed_uat is not set reliably, since it's done\n    // by clerk.js. If the developer downgrades to a pinned version of\n    // clerk.js, the suffixed uat will no longer be updated\n\n    // The best we can do is look to see if the suffixed token is expired.\n    // This means that, if a developer downgrades, and then immediately\n    // signs out, all in the span of 1 minute, then they will inadvertently\n    // remain signed in for the rest of that minute. This is a known\n    // limitation of the strategy but seems highly unlikely.\n    if (this.instanceType !== 'production') {\n      const isSuffixedSessionExpired = this.sessionExpired(suffixedSessionData);\n      if (suffixedClientUat !== '0' && clientUat === '0' && isSuffixedSessionExpired) {\n        return false;\n      }\n    }\n\n    // If a suffixed session cookie exists but the corresponding client_uat cookie is missing, fallback to using\n    // unsuffixed cookies.\n    // This handles the scenario where an app has been deployed using an SDK version that supports suffixed\n    // cookies, but FAPI for its Clerk instance has the feature disabled (eg: if we need to temporarily disable the feature).\n    if (!suffixedClientUat && suffixedSession) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private initPublishableKeyValues(options: AuthenticateRequestOptions) {\n    assertValidPublishableKey(options.publishableKey);\n    this.publishableKey = options.publishableKey;\n\n    const pk = parsePublishableKey(this.publishableKey, {\n      fatal: true,\n      proxyUrl: options.proxyUrl,\n      domain: options.domain,\n      isSatellite: options.isSatellite,\n    });\n    this.instanceType = pk.instanceType;\n    this.frontendApi = pk.frontendApi;\n  }\n\n  private initHeaderValues() {\n    this.sessionTokenInHeader = this.parseAuthorizationHeader(this.getHeader(constants.Headers.Authorization));\n    this.origin = this.getHeader(constants.Headers.Origin);\n    this.host = this.getHeader(constants.Headers.Host);\n    this.forwardedHost = this.getHeader(constants.Headers.ForwardedHost);\n    this.forwardedProto =\n      this.getHeader(constants.Headers.CloudFrontForwardedProto) || this.getHeader(constants.Headers.ForwardedProto);\n    this.referrer = this.getHeader(constants.Headers.Referrer);\n    this.userAgent = this.getHeader(constants.Headers.UserAgent);\n    this.secFetchDest = this.getHeader(constants.Headers.SecFetchDest);\n    this.accept = this.getHeader(constants.Headers.Accept);\n  }\n\n  private initCookieValues() {\n    // suffixedCookies needs to be set first because it's used in getMultipleAppsCookie\n    this.sessionTokenInCookie = this.getSuffixedOrUnSuffixedCookie(constants.Cookies.Session);\n    this.refreshTokenInCookie = this.getSuffixedCookie(constants.Cookies.Refresh);\n    this.clientUat = Number.parseInt(this.getSuffixedOrUnSuffixedCookie(constants.Cookies.ClientUat) || '') || 0;\n  }\n\n  private initHandshakeValues() {\n    this.devBrowserToken =\n      this.getQueryParam(constants.QueryParameters.DevBrowser) ||\n      this.getSuffixedOrUnSuffixedCookie(constants.Cookies.DevBrowser);\n    // Using getCookie since we don't suffix the handshake token cookie\n    this.handshakeToken =\n      this.getQueryParam(constants.QueryParameters.Handshake) || this.getCookie(constants.Cookies.Handshake);\n    this.handshakeRedirectLoopCounter = Number(this.getCookie(constants.Cookies.RedirectCount)) || 0;\n    this.handshakeNonce =\n      this.getQueryParam(constants.QueryParameters.HandshakeNonce) || this.getCookie(constants.Cookies.HandshakeNonce);\n  }\n\n  private getQueryParam(name: string) {\n    return this.clerkRequest.clerkUrl.searchParams.get(name);\n  }\n\n  private getHeader(name: string) {\n    return this.clerkRequest.headers.get(name) || undefined;\n  }\n\n  private getCookie(name: string) {\n    return this.clerkRequest.cookies.get(name) || undefined;\n  }\n\n  private getSuffixedCookie(name: string) {\n    return this.getCookie(getSuffixedCookieName(name, this.cookieSuffix)) || undefined;\n  }\n\n  private getSuffixedOrUnSuffixedCookie(cookieName: string) {\n    if (this.usesSuffixedCookies()) {\n      return this.getSuffixedCookie(cookieName);\n    }\n    return this.getCookie(cookieName);\n  }\n\n  private parseAuthorizationHeader(authorizationHeader: string | undefined | null): string | undefined {\n    if (!authorizationHeader) {\n      return undefined;\n    }\n\n    const [scheme, token] = authorizationHeader.split(' ', 2);\n\n    if (!token) {\n      // No scheme specified, treat the entire value as the token\n      return scheme;\n    }\n\n    if (scheme === 'Bearer') {\n      return token;\n    }\n\n    // Skip all other schemes\n    return undefined;\n  }\n\n  private tokenHasIssuer(token: string): boolean {\n    const { data, errors } = decodeJwt(token);\n    if (errors) {\n      return false;\n    }\n    return !!data.payload.iss;\n  }\n\n  private tokenBelongsToInstance(token: string): boolean {\n    if (!token) {\n      return false;\n    }\n\n    const { data, errors } = decodeJwt(token);\n    if (errors) {\n      return false;\n    }\n    const tokenIssuer = data.payload.iss.replace(/https?:\\/\\//gi, '');\n    return this.frontendApi === tokenIssuer;\n  }\n\n  private sessionExpired(jwt: Jwt | undefined): boolean {\n    return !!jwt && jwt?.payload.exp <= (Date.now() / 1000) >> 0;\n  }\n}\n\nexport type { AuthenticateContext };\n\nexport const createAuthenticateContext = async (\n  clerkRequest: ClerkRequest,\n  options: AuthenticateRequestOptions,\n): Promise<AuthenticateContext> => {\n  const cookieSuffix = options.publishableKey\n    ? await getCookieSuffix(options.publishableKey, runtime.crypto.subtle)\n    : '';\n  return new AuthenticateContext(cookieSuffix, clerkRequest, options);\n};\n","import { createCheckAuthorization } from '@clerk/shared/authorization';\nimport { __experimental_JWTPayloadToAuthObjectProperties } from '@clerk/shared/jwtPayloadParser';\nimport type {\n  CheckAuthorizationFromSessionClaims,\n  JwtPayload,\n  ServerGetToken,\n  ServerGetTokenOptions,\n  SessionStatusClaim,\n  SharedSignedInAuthObjectProperties,\n} from '@clerk/types';\n\nimport type { CreateBackendApiOptions } from '../api';\nimport { createBackendApiClient } from '../api';\nimport type { AuthenticateContext } from './authenticateContext';\n\ntype AuthObjectDebugData = Record<string, any>;\ntype AuthObjectDebug = () => AuthObjectDebugData;\n\n/**\n * @internal\n */\nexport type SignedInAuthObjectOptions = CreateBackendApiOptions & {\n  token: string;\n};\n\n/**\n * @internal\n */\nexport type SignedInAuthObject = SharedSignedInAuthObjectProperties & {\n  getToken: ServerGetToken;\n  has: CheckAuthorizationFromSessionClaims;\n  debug: AuthObjectDebug;\n};\n\n/**\n * @internal\n */\nexport type SignedOutAuthObject = {\n  sessionClaims: null;\n  sessionId: null;\n  sessionStatus: SessionStatusClaim | null;\n  actor: null;\n  userId: null;\n  orgId: null;\n  orgRole: null;\n  orgSlug: null;\n  orgPermissions: null;\n  /**\n   * Factor Verification Age\n   * Each item represents the minutes that have passed since the last time a first or second factor were verified.\n   * [fistFactorAge, secondFactorAge]\n   */\n  factorVerificationAge: null;\n  getToken: ServerGetToken;\n  has: CheckAuthorizationFromSessionClaims;\n  debug: AuthObjectDebug;\n};\n\n/**\n * @internal\n */\nexport type AuthObject = SignedInAuthObject | SignedOutAuthObject;\n\nconst createDebug = (data: AuthObjectDebugData | undefined) => {\n  return () => {\n    const res = { ...data };\n    res.secretKey = (res.secretKey || '').substring(0, 7);\n    res.jwtKey = (res.jwtKey || '').substring(0, 7);\n    return { ...res };\n  };\n};\n\n/**\n * @internal\n */\nexport function signedInAuthObject(\n  authenticateContext: AuthenticateContext,\n  sessionToken: string,\n  sessionClaims: JwtPayload,\n): SignedInAuthObject {\n  const { actor, sessionId, sessionStatus, userId, orgId, orgRole, orgSlug, orgPermissions, factorVerificationAge } =\n    __experimental_JWTPayloadToAuthObjectProperties(sessionClaims);\n  const apiClient = createBackendApiClient(authenticateContext);\n  const getToken = createGetToken({\n    sessionId,\n    sessionToken,\n    fetcher: async (...args) => (await apiClient.sessions.getToken(...args)).jwt,\n  });\n  return {\n    actor,\n    sessionClaims,\n    sessionId,\n    sessionStatus,\n    userId,\n    orgId,\n    orgRole,\n    orgSlug,\n    orgPermissions,\n    factorVerificationAge,\n    getToken,\n    has: createCheckAuthorization({\n      orgId,\n      orgRole,\n      orgPermissions,\n      userId,\n      factorVerificationAge,\n      features: (sessionClaims.fea as string) || '',\n      plans: (sessionClaims.pla as string) || '',\n    }),\n    debug: createDebug({ ...authenticateContext, sessionToken }),\n  };\n}\n\n/**\n * @internal\n */\nexport function signedOutAuthObject(\n  debugData?: AuthObjectDebugData,\n  initialSessionStatus?: SessionStatusClaim,\n): SignedOutAuthObject {\n  return {\n    sessionClaims: null,\n    sessionId: null,\n    sessionStatus: initialSessionStatus ?? null,\n    userId: null,\n    actor: null,\n    orgId: null,\n    orgRole: null,\n    orgSlug: null,\n    orgPermissions: null,\n    factorVerificationAge: null,\n    getToken: () => Promise.resolve(null),\n    has: () => false,\n    debug: createDebug(debugData),\n  };\n}\n\n/**\n * Auth objects moving through the server -> client boundary need to be serializable\n * as we need to ensure that they can be transferred via the network as pure strings.\n * Some frameworks like Remix or Next (/pages dir only) handle this serialization by simply\n * ignoring any non-serializable keys, however Nextjs /app directory is stricter and\n * throws an error if a non-serializable value is found.\n * @internal\n */\nexport const makeAuthObjectSerializable = <T extends Record<string, unknown>>(obj: T): T => {\n  // remove any non-serializable props from the returned object\n\n  const { debug, getToken, has, ...rest } = obj as unknown as AuthObject;\n  return rest as unknown as T;\n};\n\ntype TokenFetcher = (sessionId: string, template: string) => Promise<string>;\n\ntype CreateGetToken = (params: { sessionId: string; sessionToken: string; fetcher: TokenFetcher }) => ServerGetToken;\n\nconst createGetToken: CreateGetToken = params => {\n  const { fetcher, sessionToken, sessionId } = params || {};\n\n  return async (options: ServerGetTokenOptions = {}) => {\n    if (!sessionId) {\n      return null;\n    }\n\n    if (options.template) {\n      return fetcher(sessionId, options.template);\n    }\n\n    return sessionToken;\n  };\n};\n","const SEPARATOR = '/';\nconst MULTIPLE_SEPARATOR_REGEX = new RegExp('(?<!:)' + SEPARATOR + '{1,}', 'g');\n\ntype PathString = string | null | undefined;\n\nexport function joinPaths(...args: PathString[]): string {\n  return args\n    .filter(p => p)\n    .join(SEPARATOR)\n    .replace(MULTIPLE_SEPARATOR_REGEX, SEPARATOR);\n}\n","import type { RequestFunction } from '../request';\n\nexport abstract class AbstractAPI {\n  constructor(protected request: RequestFunction) {}\n\n  protected requireId(id: string) {\n    if (!id) {\n      throw new Error('A valid resource ID is required.');\n    }\n  }\n}\n","import { joinPaths } from '../../util/path';\nimport type { ActorToken } from '../resources/ActorToken';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/actor_tokens';\n\ntype ActorTokenActorCreateParams = {\n  /**\n   * The ID of the actor.\n   */\n  sub: string;\n  /**\n   * Additional properties of the actor.\n   */\n  additionalProperties?: { [k: string]: any };\n};\n\ntype ActorTokenCreateParams = {\n  /**\n   * The ID of the user being impersonated.\n   */\n  userId: string;\n  /**\n   * The actor payload. It needs to include a sub property which should contain the ID of the actor.\n   *\n   * @remarks\n   * This whole payload will be also included in the JWT session token.\n   */\n  actor: ActorTokenActorCreateParams;\n  /**\n   * Optional parameter to specify the life duration of the actor token in seconds.\n   *\n   * @remarks\n   * By default, the duration is 1 hour.\n   */\n  expiresInSeconds?: number | undefined;\n  /**\n   * The maximum duration that the session which will be created by the generated actor token should last.\n   *\n   * @remarks\n   * By default, the duration of a session created via an actor token, lasts 30 minutes.\n   */\n  sessionMaxDurationInSeconds?: number | undefined;\n};\n\nexport class ActorTokenAPI extends AbstractAPI {\n  public async create(params: ActorTokenCreateParams) {\n    return this.request<ActorToken>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async revoke(actorTokenId: string) {\n    this.requireId(actorTokenId);\n    return this.request<ActorToken>({\n      method: 'POST',\n      path: joinPaths(basePath, actorTokenId, 'revoke'),\n    });\n  }\n}\n","import { joinPaths } from '../../util/path';\nimport type { AccountlessApplication } from '../resources/AccountlessApplication';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/accountless_applications';\n\nexport class AccountlessApplicationAPI extends AbstractAPI {\n  public async createAccountlessApplication() {\n    return this.request<AccountlessApplication>({\n      method: 'POST',\n      path: basePath,\n    });\n  }\n\n  public async completeAccountlessApplicationOnboarding() {\n    return this.request<AccountlessApplication>({\n      method: 'POST',\n      path: joinPaths(basePath, 'complete'),\n    });\n  }\n}\n","import type { ClerkPaginationRequest } from '@clerk/types';\n\nimport { joinPaths } from '../../util/path';\nimport type { AllowlistIdentifier } from '../resources/AllowlistIdentifier';\nimport type { DeletedObject } from '../resources/DeletedObject';\nimport type { PaginatedResourceResponse } from '../resources/Deserializer';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/allowlist_identifiers';\n\ntype AllowlistIdentifierCreateParams = {\n  identifier: string;\n  notify: boolean;\n};\n\nexport class AllowlistIdentifierAPI extends AbstractAPI {\n  public async getAllowlistIdentifierList(params: ClerkPaginationRequest = {}) {\n    return this.request<PaginatedResourceResponse<AllowlistIdentifier[]>>({\n      method: 'GET',\n      path: basePath,\n      queryParams: { ...params, paginated: true },\n    });\n  }\n\n  public async createAllowlistIdentifier(params: AllowlistIdentifierCreateParams) {\n    return this.request<AllowlistIdentifier>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async deleteAllowlistIdentifier(allowlistIdentifierId: string) {\n    this.requireId(allowlistIdentifierId);\n    return this.request<DeletedObject>({\n      method: 'DELETE',\n      path: joinPaths(basePath, allowlistIdentifierId),\n    });\n  }\n}\n","import { joinPaths } from '../../util/path';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/beta_features';\n\ntype ChangeDomainParams = {\n  /**\n   * The new home URL of the production instance e.g. https://www.example.com\n   */\n  homeUrl?: string;\n  /**\n   * Whether this is a domain for a secondary app, meaning that any subdomain\n   * provided is significant and will be stored as part of the domain. This is\n   * useful for supporting multiple apps (one primary and multiple secondaries)\n   * on the same root domain (eTLD+1).\n   */\n  isSecondary?: boolean;\n};\n\nexport class BetaFeaturesAPI extends AbstractAPI {\n  /**\n   * Change the domain of a production instance.\n   *\n   * Changing the domain requires updating the DNS records accordingly, deploying new SSL certificates,\n   * updating your Social Connection's redirect URLs and setting the new keys in your code.\n   *\n   * @remarks\n   * WARNING: Changing your domain will invalidate all current user sessions (i.e. users will be logged out).\n   *          Also, while your application is being deployed, a small downtime is expected to occur.\n   */\n  public async changeDomain(params: ChangeDomainParams) {\n    return this.request<void>({\n      method: 'POST',\n      path: joinPaths(basePath, 'change_domain'),\n      bodyParams: params,\n    });\n  }\n}\n","import type { ClerkPaginationRequest } from '@clerk/types';\n\nimport { joinPaths } from '../../util/path';\nimport type { BlocklistIdentifier } from '../resources/BlocklistIdentifier';\nimport type { DeletedObject } from '../resources/DeletedObject';\nimport type { PaginatedResourceResponse } from '../resources/Deserializer';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/blocklist_identifiers';\n\ntype BlocklistIdentifierCreateParams = {\n  identifier: string;\n};\n\nexport class BlocklistIdentifierAPI extends AbstractAPI {\n  public async getBlocklistIdentifierList(params: ClerkPaginationRequest = {}) {\n    return this.request<PaginatedResourceResponse<BlocklistIdentifier[]>>({\n      method: 'GET',\n      path: basePath,\n      queryParams: params,\n    });\n  }\n\n  public async createBlocklistIdentifier(params: BlocklistIdentifierCreateParams) {\n    return this.request<BlocklistIdentifier>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async deleteBlocklistIdentifier(blocklistIdentifierId: string) {\n    this.requireId(blocklistIdentifierId);\n    return this.request<DeletedObject>({\n      method: 'DELETE',\n      path: joinPaths(basePath, blocklistIdentifierId),\n    });\n  }\n}\n","import type { ClerkPaginationRequest } from '@clerk/types';\n\nimport { joinPaths } from '../../util/path';\nimport type { Client } from '../resources/Client';\nimport type { PaginatedResourceResponse } from '../resources/Deserializer';\nimport type { HandshakePayload } from '../resources/HandshakePayload';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/clients';\n\ntype GetHandshakePayloadParams = {\n  nonce: string;\n};\n\nexport class ClientAPI extends AbstractAPI {\n  public async getClientList(params: ClerkPaginationRequest = {}) {\n    return this.request<PaginatedResourceResponse<Client[]>>({\n      method: 'GET',\n      path: basePath,\n      queryParams: { ...params, paginated: true },\n    });\n  }\n\n  public async getClient(clientId: string) {\n    this.requireId(clientId);\n    return this.request<Client>({\n      method: 'GET',\n      path: joinPaths(basePath, clientId),\n    });\n  }\n\n  public verifyClient(token: string) {\n    return this.request<Client>({\n      method: 'POST',\n      path: joinPaths(basePath, 'verify'),\n      bodyParams: { token },\n    });\n  }\n\n  public async getHandshakePayload(queryParams: GetHandshakePayloadParams) {\n    return this.request<HandshakePayload>({\n      method: 'GET',\n      path: joinPaths(basePath, 'handshake_payload'),\n      queryParams,\n    });\n  }\n}\n","import { joinPaths } from '../../util/path';\nimport type { DeletedObject } from '../resources/DeletedObject';\nimport type { PaginatedResourceResponse } from '../resources/Deserializer';\nimport type { Domain } from '../resources/Domain';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/domains';\n\ntype AddDomainParams = {\n  /**\n   * The new domain name. For development instances, can contain the port, i.e myhostname:3000. For production instances, must be a valid FQDN, i.e mysite.com. Cannot contain protocol scheme.\n   */\n  name: string;\n  /**\n   * Marks the new domain as satellite. Only true is accepted at the moment.\n   */\n  is_satellite: boolean;\n  /**\n   * The full URL of the proxy which will forward requests to the Clerk Frontend API for this domain. Applicable only to production instances.\n   */\n  proxy_url?: string | null;\n};\n\ntype UpdateDomainParams = Partial<Pick<AddDomainParams, 'name' | 'proxy_url'>> & {\n  /**\n   * The ID of the domain that will be updated.\n   */\n  domainId: string;\n  /**\n   * Whether this is a domain for a secondary app, meaning that any subdomain provided is significant\n   * and will be stored as part of the domain. This is useful for supporting multiple apps\n   * (one primary and multiple secondaries) on the same root domain (eTLD+1).\n   */\n  is_secondary?: boolean | null;\n};\n\nexport class DomainAPI extends AbstractAPI {\n  public async list() {\n    return this.request<PaginatedResourceResponse<Domain[]>>({\n      method: 'GET',\n      path: basePath,\n    });\n  }\n\n  public async add(params: AddDomainParams) {\n    return this.request<Domain>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async update(params: UpdateDomainParams) {\n    const { domainId, ...bodyParams } = params;\n\n    this.requireId(domainId);\n\n    return this.request<Domain>({\n      method: 'PATCH',\n      path: joinPaths(basePath, domainId),\n      bodyParams: bodyParams,\n    });\n  }\n\n  /**\n   * Deletes a satellite domain for the instance.\n   * It is currently not possible to delete the instance's primary domain.\n   */\n  public async delete(satelliteDomainId: string) {\n    return this.deleteDomain(satelliteDomainId);\n  }\n\n  /**\n   * @deprecated Use `delete` instead\n   */\n  public async deleteDomain(satelliteDomainId: string) {\n    this.requireId(satelliteDomainId);\n    return this.request<DeletedObject>({\n      method: 'DELETE',\n      path: joinPaths(basePath, satelliteDomainId),\n    });\n  }\n}\n","import { joinPaths } from '../../util/path';\nimport type { DeletedObject, EmailAddress } from '../resources';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/email_addresses';\n\ntype CreateEmailAddressParams = {\n  userId: string;\n  emailAddress: string;\n  verified?: boolean;\n  primary?: boolean;\n};\n\ntype UpdateEmailAddressParams = {\n  verified?: boolean;\n  primary?: boolean;\n};\n\nexport class EmailAddressAPI extends AbstractAPI {\n  public async getEmailAddress(emailAddressId: string) {\n    this.requireId(emailAddressId);\n\n    return this.request<EmailAddress>({\n      method: 'GET',\n      path: joinPaths(basePath, emailAddressId),\n    });\n  }\n\n  public async createEmailAddress(params: CreateEmailAddressParams) {\n    return this.request<EmailAddress>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async updateEmailAddress(emailAddressId: string, params: UpdateEmailAddressParams = {}) {\n    this.requireId(emailAddressId);\n\n    return this.request<EmailAddress>({\n      method: 'PATCH',\n      path: joinPaths(basePath, emailAddressId),\n      bodyParams: params,\n    });\n  }\n\n  public async deleteEmailAddress(emailAddressId: string) {\n    this.requireId(emailAddressId);\n\n    return this.request<DeletedObject>({\n      method: 'DELETE',\n      path: joinPaths(basePath, emailAddressId),\n    });\n  }\n}\n","import { joinPaths } from '../../util/path';\nimport type { Instance } from '../resources/Instance';\nimport type { InstanceRestrictions } from '../resources/InstanceRestrictions';\nimport type { OrganizationSettings } from '../resources/OrganizationSettings';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/instance';\n\ntype UpdateParams = {\n  /**\n   * Toggles test mode for this instance, allowing the use of test email addresses and phone numbers.\n   *\n   * @remarks Defaults to true for development instances.\n   */\n  testMode?: boolean | null | undefined;\n  /**\n   * Whether the instance should be using the HIBP service to check passwords for breaches\n   */\n  hibp?: boolean | null | undefined;\n  /**\n   * The \"enhanced_email_deliverability\" feature will send emails from \"verifications@clerk.dev\" instead of your domain.\n   *\n   * @remarks This can be helpful if you do not have a high domain reputation.\n   */\n  enhancedEmailDeliverability?: boolean | null | undefined;\n  supportEmail?: string | null | undefined;\n  clerkJsVersion?: string | null | undefined;\n  developmentOrigin?: string | null | undefined;\n  /**\n   * For browser-like stacks such as browser extensions, Electron, or Capacitor.js the instance allowed origins need to be updated with the request origin value.\n   *\n   * @remarks For Chrome extensions popup, background, or service worker pages the origin is chrome-extension://extension_uiid. For Electron apps the default origin is http://localhost:3000. For Capacitor, the origin is capacitor://localhost.\n   */\n  allowedOrigins?: Array<string> | undefined;\n  /**\n   * Whether the instance should use URL-based session syncing in development mode (i.e. without third-party cookies).\n   */\n  urlBasedSessionSyncing?: boolean | null | undefined;\n};\n\ntype UpdateRestrictionsParams = {\n  allowlist?: boolean | null | undefined;\n  blocklist?: boolean | null | undefined;\n  blockEmailSubaddresses?: boolean | null | undefined;\n  blockDisposableEmailDomains?: boolean | null | undefined;\n  ignoreDotsForGmailAddresses?: boolean | null | undefined;\n};\n\ntype UpdateOrganizationSettingsParams = {\n  enabled?: boolean | null | undefined;\n  maxAllowedMemberships?: number | null | undefined;\n  adminDeleteEnabled?: boolean | null | undefined;\n  domainsEnabled?: boolean | null | undefined;\n  /**\n   * Specifies which [enrollment modes](https://clerk.com/docs/organizations/verified-domains#enrollment-mode) to enable for your Organization Domains.\n   *\n   * @remarks Supported modes are 'automatic_invitation' & 'automatic_suggestion'.\n   */\n  domainsEnrollmentModes?: Array<string> | undefined;\n  /**\n   * Specifies what the default organization role is for an organization creator.\n   */\n  creatorRoleId?: string | null | undefined;\n  /**\n   * Specifies what the default organization role is for the organization domains.\n   */\n  domainsDefaultRoleId?: string | null | undefined;\n};\n\nexport class InstanceAPI extends AbstractAPI {\n  public async get() {\n    return this.request<Instance>({\n      method: 'GET',\n      path: basePath,\n    });\n  }\n\n  public async update(params: UpdateParams) {\n    return this.request<void>({\n      method: 'PATCH',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async updateRestrictions(params: UpdateRestrictionsParams) {\n    return this.request<InstanceRestrictions>({\n      method: 'PATCH',\n      path: joinPaths(basePath, 'restrictions'),\n      bodyParams: params,\n    });\n  }\n\n  public async updateOrganizationSettings(params: UpdateOrganizationSettingsParams) {\n    return this.request<OrganizationSettings>({\n      method: 'PATCH',\n      path: joinPaths(basePath, 'organization_settings'),\n      bodyParams: params,\n    });\n  }\n}\n","import type { ClerkPaginationRequest } from '@clerk/types';\n\nimport { joinPaths } from '../../util/path';\nimport type { PaginatedResourceResponse } from '../resources/Deserializer';\nimport type { InvitationStatus } from '../resources/Enums';\nimport type { Invitation } from '../resources/Invitation';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/invitations';\n\ntype CreateParams = {\n  emailAddress: string;\n  redirectUrl?: string;\n  publicMetadata?: UserPublicMetadata;\n  notify?: boolean;\n  ignoreExisting?: boolean;\n};\n\ntype GetInvitationListParams = ClerkPaginationRequest<{\n  /**\n   * Filters invitations based on their status.\n   *\n   * @example\n   * Get all revoked invitations\n   * ```ts\n   * import { createClerkClient } from '@clerk/backend';\n   * const clerkClient = createClerkClient(...)\n   * await clerkClient.invitations.getInvitationList({ status: 'revoked' })\n   * ```\n   */\n  status?: InvitationStatus;\n  /**\n   * Filters invitations based on `email_address` or `id`.\n   *\n   * @example\n   * Get all invitations for a specific email address\n   * ```ts\n   * import { createClerkClient } from '@clerk/backend';\n   * const clerkClient = createClerkClient(...)\n   * await clerkClient.invitations.getInvitationList({ query: 'user@example.com' })\n   * ```\n   */\n  query?: string;\n}>;\n\nexport class InvitationAPI extends AbstractAPI {\n  public async getInvitationList(params: GetInvitationListParams = {}) {\n    return this.request<PaginatedResourceResponse<Invitation[]>>({\n      method: 'GET',\n      path: basePath,\n      queryParams: { ...params, paginated: true },\n    });\n  }\n\n  public async createInvitation(params: CreateParams) {\n    return this.request<Invitation>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async revokeInvitation(invitationId: string) {\n    this.requireId(invitationId);\n    return this.request<Invitation>({\n      method: 'POST',\n      path: joinPaths(basePath, invitationId, 'revoke'),\n    });\n  }\n}\n","import type { JwksJSON } from '../resources/JSON';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/jwks';\n\nexport class JwksAPI extends AbstractAPI {\n  public async getJwks() {\n    return this.request<JwksJSON>({\n      method: 'GET',\n      path: basePath,\n    });\n  }\n}\n","import type { ClerkPaginationRequest } from '@clerk/types';\nimport { joinPaths } from 'src/util/path';\n\nimport type { DeletedObject, JwtTemplate } from '../resources';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/jwt_templates';\n\ntype Claims = object;\n\ntype CreateJWTTemplateParams = {\n  /**\n   * JWT template name\n   */\n  name: string;\n  /**\n   * JWT template claims in JSON format\n   */\n  claims: Claims;\n  /**\n   * JWT token lifetime\n   */\n  lifetime?: number | null | undefined;\n  /**\n   * JWT token allowed clock skew\n   */\n  allowedClockSkew?: number | null | undefined;\n  /**\n   * Whether a custom signing key/algorithm is also provided for this template\n   */\n  customSigningKey?: boolean | undefined;\n  /**\n   * The custom signing algorithm to use when minting JWTs. Required if `custom_signing_key` is `true`.\n   */\n  signingAlgorithm?: string | null | undefined;\n  /**\n   * The custom signing private key to use when minting JWTs. Required if `custom_signing_key` is `true`.\n   */\n  signingKey?: string | null | undefined;\n};\n\ntype UpdateJWTTemplateParams = CreateJWTTemplateParams & {\n  /**\n   * JWT template ID\n   */\n  templateId: string;\n};\n\nexport class JwtTemplatesApi extends AbstractAPI {\n  public async list(params: ClerkPaginationRequest = {}) {\n    return this.request<JwtTemplate[]>({\n      method: 'GET',\n      path: basePath,\n      queryParams: { ...params, paginated: true },\n    });\n  }\n\n  public async get(templateId: string) {\n    this.requireId(templateId);\n\n    return this.request<JwtTemplate>({\n      method: 'GET',\n      path: joinPaths(basePath, templateId),\n    });\n  }\n\n  public async create(params: CreateJWTTemplateParams) {\n    return this.request<JwtTemplate>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async update(params: UpdateJWTTemplateParams) {\n    const { templateId, ...bodyParams } = params;\n\n    this.requireId(templateId);\n    return this.request<JwtTemplate>({\n      method: 'PATCH',\n      path: joinPaths(basePath, templateId),\n      bodyParams,\n    });\n  }\n\n  public async delete(templateId: string) {\n    this.requireId(templateId);\n\n    return this.request<DeletedObject>({\n      method: 'DELETE',\n      path: joinPaths(basePath, templateId),\n    });\n  }\n}\n","import type { ClerkPaginationRequest, OrganizationEnrollmentMode } from '@clerk/types';\n\nimport { runtime } from '../../runtime';\nimport { joinPaths } from '../../util/path';\nimport type {\n  Organization,\n  OrganizationDomain,\n  OrganizationInvitation,\n  OrganizationInvitationStatus,\n  OrganizationMembership,\n} from '../resources';\nimport type { PaginatedResourceResponse } from '../resources/Deserializer';\nimport type { OrganizationMembershipRole } from '../resources/Enums';\nimport { AbstractAPI } from './AbstractApi';\nimport type { WithSign } from './util-types';\n\nconst basePath = '/organizations';\n\ntype MetadataParams<TPublic = OrganizationPublicMetadata, TPrivate = OrganizationPrivateMetadata> = {\n  publicMetadata?: TPublic;\n  privateMetadata?: TPrivate;\n};\n\ntype GetOrganizationListParams = ClerkPaginationRequest<{\n  includeMembersCount?: boolean;\n  query?: string;\n  orderBy?: WithSign<'name' | 'created_at' | 'members_count'>;\n  organizationId?: string[];\n}>;\n\ntype CreateParams = {\n  name: string;\n  slug?: string;\n  /* The User id for the user creating the organization. The user will become an administrator for the organization. */\n  createdBy?: string;\n  maxAllowedMemberships?: number;\n} & MetadataParams;\n\ntype GetOrganizationParams = ({ organizationId: string } | { slug: string }) & {\n  includeMembersCount?: boolean;\n};\n\ntype UpdateParams = {\n  name?: string;\n  slug?: string;\n  maxAllowedMemberships?: number;\n} & MetadataParams;\n\ntype UpdateLogoParams = {\n  file: Blob | File;\n  uploaderUserId?: string;\n};\n\ntype UpdateMetadataParams = MetadataParams;\n\ntype GetOrganizationMembershipListParams = ClerkPaginationRequest<{\n  organizationId: string;\n\n  /**\n   * Sorts organizations memberships by phone_number, email_address, created_at, first_name, last_name or username.\n   * By prepending one of those values with + or -, we can choose to sort in ascending (ASC) or descending (DESC) order.\n   */\n  orderBy?: WithSign<'phone_number' | 'email_address' | 'created_at' | 'first_name' | 'last_name' | 'username'>;\n\n  /**\n   * Returns users with the user ids specified. For each user id, the `+` and `-` can be\n   * prepended to the id, which denote whether the respective user id should be included or\n   * excluded from the result set. Accepts up to 100 user ids. Any user ids not found are ignored.\n   */\n  userId?: string[];\n\n  /* Returns users with the specified email addresses. Accepts up to 100 email addresses. Any email addresses not found are ignored. */\n  emailAddress?: string[];\n\n  /* Returns users with the specified phone numbers. Accepts up to 100 phone numbers. Any phone numbers not found are ignored. */\n  phoneNumber?: string[];\n\n  /* Returns users with the specified usernames. Accepts up to 100 usernames. Any usernames not found are ignored. */\n  username?: string[];\n\n  /* Returns users with the specified web3 wallet addresses. Accepts up to 100 web3 wallet addresses. Any web3 wallet addressed not found are ignored. */\n  web3Wallet?: string[];\n\n  /* Returns users with the specified roles. Accepts up to 100 roles. Any roles not found are ignored. */\n  role?: OrganizationMembershipRole[];\n\n  /**\n   * Returns users that match the given query.\n   * For possible matches, we check the email addresses, phone numbers, usernames, web3 wallets, user ids, first and last names.\n   * The query value doesn't need to match the exact value you are looking for, it is capable of partial matches as well.\n   */\n  query?: string;\n\n  /**\n   * Returns users with emails that match the given query, via case-insensitive partial match.\n   * For example, `email_address_query=ello` will match a user with the email `HELLO@example.com`.\n   */\n  emailAddressQuery?: string;\n\n  /**\n   * Returns users with phone numbers that match the given query, via case-insensitive partial match.\n   * For example, `phone_number_query=555` will match a user with the phone number `+1555xxxxxxx`.\n   */\n  phoneNumberQuery?: string;\n\n  /**\n   * Returns users with usernames that match the given query, via case-insensitive partial match.\n   * For example, `username_query=CoolUser` will match a user with the username `SomeCoolUser`.\n   */\n  usernameQuery?: string;\n\n  /* Returns users with names that match the given query, via case-insensitive partial match. */\n  nameQuery?: string;\n\n  /**\n   * Returns users whose last session activity was before the given date (with millisecond precision).\n   * Example: use 1700690400000 to retrieve users whose last session activity was before 2023-11-23.\n   */\n  lastActiveAtBefore?: number;\n  /**\n   * Returns users whose last session activity was after the given date (with millisecond precision).\n   * Example: use 1700690400000 to retrieve users whose last session activity was after 2023-11-23.\n   */\n  lastActiveAtAfter?: number;\n\n  /**\n   * Returns users who have been created before the given date (with millisecond precision).\n   * Example: use 1730160000000 to retrieve users who have been created before 2024-10-29.\n   */\n  createdAtBefore?: number;\n\n  /**\n   * Returns users who have been created after the given date (with millisecond precision).\n   * Example: use 1730160000000 to retrieve users who have been created after 2024-10-29.\n   */\n  createdAtAfter?: number;\n}>;\n\ntype GetInstanceOrganizationMembershipListParams = ClerkPaginationRequest<{\n  /**\n   * Sorts organizations memberships by phone_number, email_address, created_at, first_name, last_name or username.\n   * By prepending one of those values with + or -, we can choose to sort in ascending (ASC) or descending (DESC) order.\n   */\n  orderBy?: WithSign<'phone_number' | 'email_address' | 'created_at' | 'first_name' | 'last_name' | 'username'>;\n}>;\n\ntype CreateOrganizationMembershipParams = {\n  organizationId: string;\n  userId: string;\n  role: OrganizationMembershipRole;\n};\n\ntype UpdateOrganizationMembershipParams = CreateOrganizationMembershipParams;\n\ntype UpdateOrganizationMembershipMetadataParams = {\n  organizationId: string;\n  userId: string;\n} & MetadataParams<OrganizationMembershipPublicMetadata>;\n\ntype DeleteOrganizationMembershipParams = {\n  organizationId: string;\n  userId: string;\n};\n\ntype CreateOrganizationInvitationParams = {\n  organizationId: string;\n  inviterUserId?: string;\n  emailAddress: string;\n  role: OrganizationMembershipRole;\n  redirectUrl?: string;\n  publicMetadata?: OrganizationInvitationPublicMetadata;\n};\n\ntype CreateBulkOrganizationInvitationParams = Array<{\n  inviterUserId?: string;\n  emailAddress: string;\n  role: OrganizationMembershipRole;\n  redirectUrl?: string;\n  publicMetadata?: OrganizationInvitationPublicMetadata;\n}>;\n\ntype GetOrganizationInvitationListParams = ClerkPaginationRequest<{\n  organizationId: string;\n  status?: OrganizationInvitationStatus[];\n}>;\n\ntype GetOrganizationInvitationParams = {\n  organizationId: string;\n  invitationId: string;\n};\n\ntype RevokeOrganizationInvitationParams = {\n  organizationId: string;\n  invitationId: string;\n  requestingUserId?: string;\n};\n\ntype GetOrganizationDomainListParams = {\n  organizationId: string;\n  limit?: number;\n  offset?: number;\n};\n\ntype CreateOrganizationDomainParams = {\n  organizationId: string;\n  name: string;\n  enrollmentMode: OrganizationEnrollmentMode;\n  verified?: boolean;\n};\n\ntype UpdateOrganizationDomainParams = {\n  organizationId: string;\n  domainId: string;\n} & Partial<CreateOrganizationDomainParams>;\n\ntype DeleteOrganizationDomainParams = {\n  organizationId: string;\n  domainId: string;\n};\n\nexport class OrganizationAPI extends AbstractAPI {\n  public async getOrganizationList(params?: GetOrganizationListParams) {\n    return this.request<PaginatedResourceResponse<Organization[]>>({\n      method: 'GET',\n      path: basePath,\n      queryParams: params,\n    });\n  }\n\n  public async createOrganization(params: CreateParams) {\n    return this.request<Organization>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async getOrganization(params: GetOrganizationParams) {\n    const { includeMembersCount } = params;\n    const organizationIdOrSlug = 'organizationId' in params ? params.organizationId : params.slug;\n    this.requireId(organizationIdOrSlug);\n\n    return this.request<Organization>({\n      method: 'GET',\n      path: joinPaths(basePath, organizationIdOrSlug),\n      queryParams: {\n        includeMembersCount,\n      },\n    });\n  }\n\n  public async updateOrganization(organizationId: string, params: UpdateParams) {\n    this.requireId(organizationId);\n    return this.request<Organization>({\n      method: 'PATCH',\n      path: joinPaths(basePath, organizationId),\n      bodyParams: params,\n    });\n  }\n\n  public async updateOrganizationLogo(organizationId: string, params: UpdateLogoParams) {\n    this.requireId(organizationId);\n\n    const formData = new runtime.FormData();\n    formData.append('file', params?.file);\n    if (params?.uploaderUserId) {\n      formData.append('uploader_user_id', params?.uploaderUserId);\n    }\n\n    return this.request<Organization>({\n      method: 'PUT',\n      path: joinPaths(basePath, organizationId, 'logo'),\n      formData,\n    });\n  }\n\n  public async deleteOrganizationLogo(organizationId: string) {\n    this.requireId(organizationId);\n\n    return this.request<Organization>({\n      method: 'DELETE',\n      path: joinPaths(basePath, organizationId, 'logo'),\n    });\n  }\n\n  public async updateOrganizationMetadata(organizationId: string, params: UpdateMetadataParams) {\n    this.requireId(organizationId);\n\n    return this.request<Organization>({\n      method: 'PATCH',\n      path: joinPaths(basePath, organizationId, 'metadata'),\n      bodyParams: params,\n    });\n  }\n\n  public async deleteOrganization(organizationId: string) {\n    return this.request<Organization>({\n      method: 'DELETE',\n      path: joinPaths(basePath, organizationId),\n    });\n  }\n\n  public async getOrganizationMembershipList(params: GetOrganizationMembershipListParams) {\n    const { organizationId, ...queryParams } = params;\n    this.requireId(organizationId);\n\n    return this.request<PaginatedResourceResponse<OrganizationMembership[]>>({\n      method: 'GET',\n      path: joinPaths(basePath, organizationId, 'memberships'),\n      queryParams,\n    });\n  }\n\n  public async getInstanceOrganizationMembershipList(params: GetInstanceOrganizationMembershipListParams) {\n    return this.request<PaginatedResourceResponse<OrganizationMembership[]>>({\n      method: 'GET',\n      path: '/organization_memberships',\n      queryParams: params,\n    });\n  }\n\n  public async createOrganizationMembership(params: CreateOrganizationMembershipParams) {\n    const { organizationId, ...bodyParams } = params;\n    this.requireId(organizationId);\n\n    return this.request<OrganizationMembership>({\n      method: 'POST',\n      path: joinPaths(basePath, organizationId, 'memberships'),\n      bodyParams,\n    });\n  }\n\n  public async updateOrganizationMembership(params: UpdateOrganizationMembershipParams) {\n    const { organizationId, userId, ...bodyParams } = params;\n    this.requireId(organizationId);\n\n    return this.request<OrganizationMembership>({\n      method: 'PATCH',\n      path: joinPaths(basePath, organizationId, 'memberships', userId),\n      bodyParams,\n    });\n  }\n\n  public async updateOrganizationMembershipMetadata(params: UpdateOrganizationMembershipMetadataParams) {\n    const { organizationId, userId, ...bodyParams } = params;\n\n    return this.request<OrganizationMembership>({\n      method: 'PATCH',\n      path: joinPaths(basePath, organizationId, 'memberships', userId, 'metadata'),\n      bodyParams,\n    });\n  }\n\n  public async deleteOrganizationMembership(params: DeleteOrganizationMembershipParams) {\n    const { organizationId, userId } = params;\n    this.requireId(organizationId);\n\n    return this.request<OrganizationMembership>({\n      method: 'DELETE',\n      path: joinPaths(basePath, organizationId, 'memberships', userId),\n    });\n  }\n\n  public async getOrganizationInvitationList(params: GetOrganizationInvitationListParams) {\n    const { organizationId, ...queryParams } = params;\n    this.requireId(organizationId);\n\n    return this.request<PaginatedResourceResponse<OrganizationInvitation[]>>({\n      method: 'GET',\n      path: joinPaths(basePath, organizationId, 'invitations'),\n      queryParams,\n    });\n  }\n\n  public async createOrganizationInvitation(params: CreateOrganizationInvitationParams) {\n    const { organizationId, ...bodyParams } = params;\n    this.requireId(organizationId);\n\n    return this.request<OrganizationInvitation>({\n      method: 'POST',\n      path: joinPaths(basePath, organizationId, 'invitations'),\n      bodyParams,\n    });\n  }\n\n  public async createOrganizationInvitationBulk(\n    organizationId: string,\n    params: CreateBulkOrganizationInvitationParams,\n  ) {\n    this.requireId(organizationId);\n\n    return this.request<OrganizationInvitation[]>({\n      method: 'POST',\n      path: joinPaths(basePath, organizationId, 'invitations', 'bulk'),\n      bodyParams: params,\n    });\n  }\n\n  public async getOrganizationInvitation(params: GetOrganizationInvitationParams) {\n    const { organizationId, invitationId } = params;\n    this.requireId(organizationId);\n    this.requireId(invitationId);\n\n    return this.request<OrganizationInvitation>({\n      method: 'GET',\n      path: joinPaths(basePath, organizationId, 'invitations', invitationId),\n    });\n  }\n\n  public async revokeOrganizationInvitation(params: RevokeOrganizationInvitationParams) {\n    const { organizationId, invitationId, ...bodyParams } = params;\n    this.requireId(organizationId);\n\n    return this.request<OrganizationInvitation>({\n      method: 'POST',\n      path: joinPaths(basePath, organizationId, 'invitations', invitationId, 'revoke'),\n      bodyParams,\n    });\n  }\n\n  public async getOrganizationDomainList(params: GetOrganizationDomainListParams) {\n    const { organizationId, ...queryParams } = params;\n    this.requireId(organizationId);\n\n    return this.request<PaginatedResourceResponse<OrganizationDomain[]>>({\n      method: 'GET',\n      path: joinPaths(basePath, organizationId, 'domains'),\n      queryParams,\n    });\n  }\n\n  public async createOrganizationDomain(params: CreateOrganizationDomainParams) {\n    const { organizationId, ...bodyParams } = params;\n    this.requireId(organizationId);\n\n    return this.request<OrganizationDomain>({\n      method: 'POST',\n      path: joinPaths(basePath, organizationId, 'domains'),\n      bodyParams: {\n        ...bodyParams,\n        verified: bodyParams.verified ?? true,\n      },\n    });\n  }\n\n  public async updateOrganizationDomain(params: UpdateOrganizationDomainParams) {\n    const { organizationId, domainId, ...bodyParams } = params;\n    this.requireId(organizationId);\n    this.requireId(domainId);\n\n    return this.request<OrganizationDomain>({\n      method: 'PATCH',\n      path: joinPaths(basePath, organizationId, 'domains', domainId),\n      bodyParams,\n    });\n  }\n\n  public async deleteOrganizationDomain(params: DeleteOrganizationDomainParams) {\n    const { organizationId, domainId } = params;\n    this.requireId(organizationId);\n    this.requireId(domainId);\n\n    return this.request<OrganizationDomain>({\n      method: 'DELETE',\n      path: joinPaths(basePath, organizationId, 'domains', domainId),\n    });\n  }\n}\n","import type { ClerkPaginationRequest } from '@clerk/types';\n\nimport { joinPaths } from '../../util/path';\nimport type { DeletedObject } from '../resources';\nimport type { PaginatedResourceResponse } from '../resources/Deserializer';\nimport type { OAuthApplication } from '../resources/OAuthApplication';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/oauth_applications';\n\ntype CreateOAuthApplicationParams = {\n  /**\n   * The name of the new OAuth application.\n   *\n   * @remarks Max length: 256\n   */\n  name: string;\n  /**\n   * An array of redirect URIs of the new OAuth application\n   */\n  redirectUris?: Array<string> | null | undefined;\n  /**\n   * Define the allowed scopes for the new OAuth applications that dictate the user payload of the OAuth user info endpoint. Available scopes are `profile`, `email`, `public_metadata`, `private_metadata`. Provide the requested scopes as a string, separated by spaces.\n   */\n  scopes?: string | null | undefined;\n  /**\n   * If true, this client is public and you can use the Proof Key of Code Exchange (PKCE) flow.\n   */\n  public?: boolean | null | undefined;\n};\n\ntype UpdateOAuthApplicationParams = CreateOAuthApplicationParams & {\n  /**\n   * The ID of the OAuth application to update\n   */\n  oauthApplicationId: string;\n};\n\nexport class OAuthApplicationsApi extends AbstractAPI {\n  public async list(params: ClerkPaginationRequest = {}) {\n    return this.request<PaginatedResourceResponse<OAuthApplication[]>>({\n      method: 'GET',\n      path: basePath,\n      queryParams: params,\n    });\n  }\n\n  public async get(oauthApplicationId: string) {\n    this.requireId(oauthApplicationId);\n\n    return this.request<OAuthApplication>({\n      method: 'GET',\n      path: joinPaths(basePath, oauthApplicationId),\n    });\n  }\n\n  public async create(params: CreateOAuthApplicationParams) {\n    return this.request<OAuthApplication>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async update(params: UpdateOAuthApplicationParams) {\n    const { oauthApplicationId, ...bodyParams } = params;\n\n    this.requireId(oauthApplicationId);\n\n    return this.request<OAuthApplication>({\n      method: 'PATCH',\n      path: joinPaths(basePath, oauthApplicationId),\n      bodyParams,\n    });\n  }\n\n  public async delete(oauthApplicationId: string) {\n    this.requireId(oauthApplicationId);\n\n    return this.request<DeletedObject>({\n      method: 'DELETE',\n      path: joinPaths(basePath, oauthApplicationId),\n    });\n  }\n\n  public async rotateSecret(oauthApplicationId: string) {\n    this.requireId(oauthApplicationId);\n\n    return this.request<OAuthApplication>({\n      method: 'POST',\n      path: joinPaths(basePath, oauthApplicationId, 'rotate_secret'),\n    });\n  }\n}\n","import { joinPaths } from '../../util/path';\nimport type { DeletedObject, PhoneNumber } from '../resources';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/phone_numbers';\n\ntype CreatePhoneNumberParams = {\n  userId: string;\n  phoneNumber: string;\n  verified?: boolean;\n  primary?: boolean;\n  reservedForSecondFactor?: boolean;\n};\n\ntype UpdatePhoneNumberParams = {\n  verified?: boolean;\n  primary?: boolean;\n  reservedForSecondFactor?: boolean;\n};\n\nexport class PhoneNumberAPI extends AbstractAPI {\n  public async getPhoneNumber(phoneNumberId: string) {\n    this.requireId(phoneNumberId);\n\n    return this.request<PhoneNumber>({\n      method: 'GET',\n      path: joinPaths(basePath, phoneNumberId),\n    });\n  }\n\n  public async createPhoneNumber(params: CreatePhoneNumberParams) {\n    return this.request<PhoneNumber>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async updatePhoneNumber(phoneNumberId: string, params: UpdatePhoneNumberParams = {}) {\n    this.requireId(phoneNumberId);\n\n    return this.request<PhoneNumber>({\n      method: 'PATCH',\n      path: joinPaths(basePath, phoneNumberId),\n      bodyParams: params,\n    });\n  }\n\n  public async deletePhoneNumber(phoneNumberId: string) {\n    this.requireId(phoneNumberId);\n\n    return this.request<DeletedObject>({\n      method: 'DELETE',\n      path: joinPaths(basePath, phoneNumberId),\n    });\n  }\n}\n","import type { ProxyCheck } from '../resources';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/proxy_checks';\n\ntype VerifyParams = {\n  domainId: string;\n  proxyUrl: string;\n};\n\nexport class ProxyCheckAPI extends AbstractAPI {\n  public async verify(params: VerifyParams) {\n    return this.request<ProxyCheck>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n}\n","import { joinPaths } from '../../util/path';\nimport type { PaginatedResourceResponse } from '../resources/Deserializer';\nimport type { RedirectUrl } from '../resources/RedirectUrl';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/redirect_urls';\n\ntype CreateRedirectUrlParams = {\n  url: string;\n};\n\nexport class RedirectUrlAPI extends AbstractAPI {\n  public async getRedirectUrlList() {\n    return this.request<PaginatedResourceResponse<RedirectUrl[]>>({\n      method: 'GET',\n      path: basePath,\n      queryParams: { paginated: true },\n    });\n  }\n\n  public async getRedirectUrl(redirectUrlId: string) {\n    this.requireId(redirectUrlId);\n    return this.request<RedirectUrl>({\n      method: 'GET',\n      path: joinPaths(basePath, redirectUrlId),\n    });\n  }\n\n  public async createRedirectUrl(params: CreateRedirectUrlParams) {\n    return this.request<RedirectUrl>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async deleteRedirectUrl(redirectUrlId: string) {\n    this.requireId(redirectUrlId);\n    return this.request<RedirectUrl>({\n      method: 'DELETE',\n      path: joinPaths(basePath, redirectUrlId),\n    });\n  }\n}\n","import type { SamlIdpSlug } from '@clerk/types';\n\nimport { joinPaths } from '../../util/path';\nimport type { SamlConnection } from '../resources';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/saml_connections';\n\ntype SamlConnectionListParams = {\n  limit?: number;\n  offset?: number;\n};\ntype CreateSamlConnectionParams = {\n  name: string;\n  provider: SamlIdpSlug;\n  domain: string;\n  organizationId?: string;\n  idpEntityId?: string;\n  idpSsoUrl?: string;\n  idpCertificate?: string;\n  idpMetadataUrl?: string;\n  idpMetadata?: string;\n  attributeMapping?: {\n    emailAddress?: string;\n    firstName?: string;\n    lastName?: string;\n    userId?: string;\n  };\n};\n\ntype UpdateSamlConnectionParams = {\n  name?: string;\n  provider?: SamlIdpSlug;\n  domain?: string;\n  organizationId?: string;\n  idpEntityId?: string;\n  idpSsoUrl?: string;\n  idpCertificate?: string;\n  idpMetadataUrl?: string;\n  idpMetadata?: string;\n  attributeMapping?: {\n    emailAddress?: string;\n    firstName?: string;\n    lastName?: string;\n    userId?: string;\n  };\n  active?: boolean;\n  syncUserAttributes?: boolean;\n  allowSubdomains?: boolean;\n  allowIdpInitiated?: boolean;\n};\n\nexport class SamlConnectionAPI extends AbstractAPI {\n  public async getSamlConnectionList(params: SamlConnectionListParams = {}) {\n    return this.request<SamlConnection[]>({\n      method: 'GET',\n      path: basePath,\n      queryParams: params,\n    });\n  }\n\n  public async createSamlConnection(params: CreateSamlConnectionParams) {\n    return this.request<SamlConnection>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async getSamlConnection(samlConnectionId: string) {\n    this.requireId(samlConnectionId);\n    return this.request<SamlConnection>({\n      method: 'GET',\n      path: joinPaths(basePath, samlConnectionId),\n    });\n  }\n\n  public async updateSamlConnection(samlConnectionId: string, params: UpdateSamlConnectionParams = {}) {\n    this.requireId(samlConnectionId);\n\n    return this.request<SamlConnection>({\n      method: 'PATCH',\n      path: joinPaths(basePath, samlConnectionId),\n      bodyParams: params,\n    });\n  }\n  public async deleteSamlConnection(samlConnectionId: string) {\n    this.requireId(samlConnectionId);\n    return this.request<SamlConnection>({\n      method: 'DELETE',\n      path: joinPaths(basePath, samlConnectionId),\n    });\n  }\n}\n","import type { ClerkPaginationRequest, SessionStatus } from '@clerk/types';\n\nimport { joinPaths } from '../../util/path';\nimport type { Cookies } from '../resources/Cookies';\nimport type { PaginatedResourceResponse } from '../resources/Deserializer';\nimport type { Session } from '../resources/Session';\nimport type { Token } from '../resources/Token';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/sessions';\n\ntype SessionListParams = ClerkPaginationRequest<{\n  clientId?: string;\n  userId?: string;\n  status?: SessionStatus;\n}>;\n\ntype RefreshTokenParams = {\n  expired_token: string;\n  refresh_token: string;\n  request_origin: string;\n  request_originating_ip?: string;\n  request_headers?: Record<string, string[]>;\n  suffixed_cookies?: boolean;\n  format?: 'token' | 'cookie';\n};\n\ntype CreateSessionParams = {\n  userId: string;\n};\n\nexport class SessionAPI extends AbstractAPI {\n  public async getSessionList(params: SessionListParams = {}) {\n    return this.request<PaginatedResourceResponse<Session[]>>({\n      method: 'GET',\n      path: basePath,\n      queryParams: { ...params, paginated: true },\n    });\n  }\n\n  public async getSession(sessionId: string) {\n    this.requireId(sessionId);\n    return this.request<Session>({\n      method: 'GET',\n      path: joinPaths(basePath, sessionId),\n    });\n  }\n\n  public async createSession(params: CreateSessionParams) {\n    return this.request<Session>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async revokeSession(sessionId: string) {\n    this.requireId(sessionId);\n    return this.request<Session>({\n      method: 'POST',\n      path: joinPaths(basePath, sessionId, 'revoke'),\n    });\n  }\n\n  public async verifySession(sessionId: string, token: string) {\n    this.requireId(sessionId);\n    return this.request<Session>({\n      method: 'POST',\n      path: joinPaths(basePath, sessionId, 'verify'),\n      bodyParams: { token },\n    });\n  }\n\n  public async getToken(sessionId: string, template: string) {\n    this.requireId(sessionId);\n    return this.request<Token>({\n      method: 'POST',\n      path: joinPaths(basePath, sessionId, 'tokens', template || ''),\n    });\n  }\n\n  public async refreshSession(sessionId: string, params: RefreshTokenParams & { format: 'token' }): Promise<Token>;\n  public async refreshSession(sessionId: string, params: RefreshTokenParams & { format: 'cookie' }): Promise<Cookies>;\n  public async refreshSession(sessionId: string, params: RefreshTokenParams): Promise<Token>;\n  public async refreshSession(sessionId: string, params: RefreshTokenParams): Promise<Token | Cookies> {\n    this.requireId(sessionId);\n    const { suffixed_cookies, ...restParams } = params;\n    return this.request({\n      method: 'POST',\n      path: joinPaths(basePath, sessionId, 'refresh'),\n      bodyParams: restParams,\n      queryParams: { suffixed_cookies },\n    });\n  }\n}\n","import { joinPaths } from '../../util/path';\nimport type { SignInToken } from '../resources/SignInTokens';\nimport { AbstractAPI } from './AbstractApi';\n\ntype CreateSignInTokensParams = {\n  userId: string;\n  expiresInSeconds: number;\n};\n\nconst basePath = '/sign_in_tokens';\n\nexport class SignInTokenAPI extends AbstractAPI {\n  public async createSignInToken(params: CreateSignInTokensParams) {\n    return this.request<SignInToken>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async revokeSignInToken(signInTokenId: string) {\n    this.requireId(signInTokenId);\n    return this.request<SignInToken>({\n      method: 'POST',\n      path: joinPaths(basePath, signInTokenId, 'revoke'),\n    });\n  }\n}\n","import { joinPaths } from '../../util/path';\nimport type { SignUpAttempt } from '../resources/SignUpAttempt';\nimport { AbstractAPI } from './AbstractApi';\n\ntype UpdateSignUpParams = {\n  signUpAttemptId: string;\n  externalId?: string | null;\n  customAction?: boolean | null;\n};\n\nconst basePath = '/sign_ups';\n\nexport class SignUpAPI extends AbstractAPI {\n  public async get(signUpAttemptId: string) {\n    this.requireId(signUpAttemptId);\n\n    return this.request<SignUpAttempt>({\n      method: 'GET',\n      path: joinPaths(basePath, signUpAttemptId),\n    });\n  }\n\n  public async update(params: UpdateSignUpParams) {\n    const { signUpAttemptId, ...bodyParams } = params;\n\n    return this.request<SignUpAttempt>({\n      method: 'PATCH',\n      path: joinPaths(basePath, signUpAttemptId),\n      bodyParams,\n    });\n  }\n}\n","import type { TestingToken } from '../resources/TestingToken';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/testing_tokens';\n\nexport class TestingTokenAPI extends AbstractAPI {\n  public async createTestingToken() {\n    return this.request<TestingToken>({\n      method: 'POST',\n      path: basePath,\n    });\n  }\n}\n","import type { ClerkPaginationRequest, OAuthProvider, OrganizationInvitationStatus } from '@clerk/types';\n\nimport { runtime } from '../../runtime';\nimport { joinPaths } from '../../util/path';\nimport { deprecated } from '../../util/shared';\nimport type {\n  DeletedObject,\n  OauthAccessToken,\n  OrganizationInvitation,\n  OrganizationMembership,\n  User,\n} from '../resources';\nimport type { PaginatedResourceResponse } from '../resources/Deserializer';\nimport { AbstractAPI } from './AbstractApi';\nimport type { WithSign } from './util-types';\n\nconst basePath = '/users';\n\ntype UserCountParams = {\n  emailAddress?: string[];\n  phoneNumber?: string[];\n  username?: string[];\n  web3Wallet?: string[];\n  query?: string;\n  userId?: string[];\n  externalId?: string[];\n};\n\ntype UserListParams = ClerkPaginationRequest<\n  UserCountParams & {\n    orderBy?: WithSign<\n      | 'created_at'\n      | 'updated_at'\n      | 'email_address'\n      | 'web3wallet'\n      | 'first_name'\n      | 'last_name'\n      | 'phone_number'\n      | 'username'\n      | 'last_active_at'\n      | 'last_sign_in_at'\n    >;\n    last_active_at_since?: number;\n    organizationId?: string[];\n  }\n>;\n\ntype UserMetadataParams = {\n  publicMetadata?: UserPublicMetadata;\n  privateMetadata?: UserPrivateMetadata;\n  unsafeMetadata?: UserUnsafeMetadata;\n};\n\ntype PasswordHasher =\n  | 'argon2i'\n  | 'argon2id'\n  | 'awscognito'\n  | 'bcrypt'\n  | 'bcrypt_sha256_django'\n  | 'md5'\n  | 'pbkdf2_sha256'\n  | 'pbkdf2_sha256_django'\n  | 'pbkdf2_sha1'\n  | 'phpass'\n  | 'scrypt_firebase'\n  | 'scrypt_werkzeug'\n  | 'sha256'\n  | 'md5_phpass'\n  | 'ldap_ssha';\n\ntype UserPasswordHashingParams = {\n  passwordDigest: string;\n  passwordHasher: PasswordHasher;\n};\n\ntype CreateUserParams = {\n  externalId?: string;\n  emailAddress?: string[];\n  phoneNumber?: string[];\n  username?: string;\n  password?: string;\n  firstName?: string;\n  lastName?: string;\n  skipPasswordChecks?: boolean;\n  skipPasswordRequirement?: boolean;\n  skipLegalChecks?: boolean;\n  legalAcceptedAt?: Date;\n  totpSecret?: string;\n  backupCodes?: string[];\n  createdAt?: Date;\n} & UserMetadataParams &\n  (UserPasswordHashingParams | object);\n\ntype UpdateUserParams = {\n  /** The first name to assign to the user. */\n  firstName?: string;\n\n  /** The last name of the user. */\n  lastName?: string;\n\n  /** The username to give to the user. It must be unique across your instance. */\n  username?: string;\n\n  /** The plaintext password to give the user. Must be at least 8 characters long, and can not be in any list of hacked passwords. */\n  password?: string;\n\n  /** Set it to true if you're updating the user's password and want to skip any password policy settings check. This parameter can only be used when providing a password. */\n  skipPasswordChecks?: boolean;\n\n  /** Set to true to sign out the user from all their active sessions once their password is updated. This parameter can only be used when providing a password. */\n  signOutOfOtherSessions?: boolean;\n\n  /** The ID of the email address to set as primary. It must be verified, and present on the current user. */\n  primaryEmailAddressID?: string;\n\n  /** If set to true, the user will be notified that their primary email address has changed. By default, no notification is sent. */\n  notifyPrimaryEmailAddressChanged?: boolean;\n\n  /** The ID of the phone number to set as primary. It must be verified, and present on the current user. */\n  primaryPhoneNumberID?: string;\n\n  /** The ID of the web3 wallets to set as primary. It must be verified, and present on the current user. */\n  primaryWeb3WalletID?: string;\n\n  /** The ID of the image to set as the user's profile image */\n  profileImageID?: string;\n\n  /**\n   * In case TOTP is configured on the instance, you can provide the secret to enable it on the specific user without the need to reset it.\n   * Please note that currently the supported options are:\n   * - Period: 30 seconds\n   * - Code length: 6 digits\n   * - Algorithm: SHA1\n   */\n  totpSecret?: string;\n\n  /** If Backup Codes are configured on the instance, you can provide them to enable it on the specific user without the need to reset them. You must provide the backup codes in plain format or the corresponding bcrypt digest. */\n  backupCodes?: string[];\n\n  /** The ID of the user as used in your external systems or your previous authentication solution. Must be unique across your instance. */\n  externalId?: string;\n\n  /** A custom timestamp denoting when the user signed up to the application, specified in RFC3339 format (e.g. 2012-10-20T07:15:20.902Z). */\n  createdAt?: Date;\n\n  /** When set to true all legal checks are skipped. It is not recommended to skip legal checks unless you are migrating a user to Clerk. */\n  skipLegalChecks?: boolean;\n\n  /** A custom timestamp denoting when the user accepted legal requirements, specified in RFC3339 format (e.g. 2012-10-20T07:15:20.902Z). */\n  legalAcceptedAt?: Date;\n\n  /** If true, the user can delete themselves with the Frontend API. */\n  deleteSelfEnabled?: boolean;\n\n  /** If true, the user can create organizations with the Frontend API. */\n  createOrganizationEnabled?: boolean;\n\n  /** The maximum number of organizations the user can create. 0 means unlimited. */\n  createOrganizationsLimit?: number;\n} & UserMetadataParams &\n  (UserPasswordHashingParams | object);\n\ntype GetOrganizationMembershipListParams = ClerkPaginationRequest<{\n  userId: string;\n}>;\n\ntype GetOrganizationInvitationListParams = ClerkPaginationRequest<{\n  userId: string;\n  status?: OrganizationInvitationStatus;\n}>;\n\ntype VerifyPasswordParams = {\n  userId: string;\n  password: string;\n};\n\ntype VerifyTOTPParams = {\n  userId: string;\n  code: string;\n};\n\ntype DeleteUserPasskeyParams = {\n  userId: string;\n  passkeyIdentificationId: string;\n};\n\ntype DeleteWeb3WalletParams = {\n  userId: string;\n  web3WalletIdentificationId: string;\n};\n\ntype DeleteUserExternalAccountParams = {\n  userId: string;\n  externalAccountId: string;\n};\n\ntype UserID = {\n  userId: string;\n};\n\nexport class UserAPI extends AbstractAPI {\n  public async getUserList(params: UserListParams = {}) {\n    const { limit, offset, orderBy, ...userCountParams } = params;\n    // TODO(dimkl): Temporary change to populate totalCount using a 2nd BAPI call to /users/count endpoint\n    // until we update the /users endpoint to be paginated in a next BAPI version.\n    // In some edge cases the data.length != totalCount due to a creation of a user between the 2 api responses\n    const [data, totalCount] = await Promise.all([\n      this.request<User[]>({\n        method: 'GET',\n        path: basePath,\n        queryParams: params,\n      }),\n      this.getCount(userCountParams),\n    ]);\n    return { data, totalCount } as PaginatedResourceResponse<User[]>;\n  }\n\n  public async getUser(userId: string) {\n    this.requireId(userId);\n    return this.request<User>({\n      method: 'GET',\n      path: joinPaths(basePath, userId),\n    });\n  }\n\n  public async createUser(params: CreateUserParams) {\n    return this.request<User>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n\n  public async updateUser(userId: string, params: UpdateUserParams = {}) {\n    this.requireId(userId);\n\n    return this.request<User>({\n      method: 'PATCH',\n      path: joinPaths(basePath, userId),\n      bodyParams: params,\n    });\n  }\n\n  public async updateUserProfileImage(userId: string, params: { file: Blob | File }) {\n    this.requireId(userId);\n\n    const formData = new runtime.FormData();\n    formData.append('file', params?.file);\n\n    return this.request<User>({\n      method: 'POST',\n      path: joinPaths(basePath, userId, 'profile_image'),\n      formData,\n    });\n  }\n\n  public async updateUserMetadata(userId: string, params: UserMetadataParams) {\n    this.requireId(userId);\n\n    return this.request<User>({\n      method: 'PATCH',\n      path: joinPaths(basePath, userId, 'metadata'),\n      bodyParams: params,\n    });\n  }\n\n  public async deleteUser(userId: string) {\n    this.requireId(userId);\n    return this.request<User>({\n      method: 'DELETE',\n      path: joinPaths(basePath, userId),\n    });\n  }\n\n  public async getCount(params: UserCountParams = {}) {\n    return this.request<number>({\n      method: 'GET',\n      path: joinPaths(basePath, 'count'),\n      queryParams: params,\n    });\n  }\n\n  /** @deprecated Use `getUserOauthAccessToken` without the `oauth_` provider prefix . */\n  public async getUserOauthAccessToken(\n    userId: string,\n    provider: `oauth_${OAuthProvider}`,\n  ): Promise<PaginatedResourceResponse<OauthAccessToken[]>>;\n  public async getUserOauthAccessToken(\n    userId: string,\n    provider: OAuthProvider,\n  ): Promise<PaginatedResourceResponse<OauthAccessToken[]>>;\n  public async getUserOauthAccessToken(userId: string, provider: `oauth_${OAuthProvider}` | OAuthProvider) {\n    this.requireId(userId);\n    const hasPrefix = provider.startsWith('oauth_');\n    const _provider = hasPrefix ? provider : `oauth_${provider}`;\n\n    if (hasPrefix) {\n      deprecated(\n        'getUserOauthAccessToken(userId, provider)',\n        'Remove the `oauth_` prefix from the `provider` argument.',\n      );\n    }\n\n    return this.request<PaginatedResourceResponse<OauthAccessToken[]>>({\n      method: 'GET',\n      path: joinPaths(basePath, userId, 'oauth_access_tokens', _provider),\n      queryParams: { paginated: true },\n    });\n  }\n\n  public async disableUserMFA(userId: string) {\n    this.requireId(userId);\n    return this.request<UserID>({\n      method: 'DELETE',\n      path: joinPaths(basePath, userId, 'mfa'),\n    });\n  }\n\n  public async getOrganizationMembershipList(params: GetOrganizationMembershipListParams) {\n    const { userId, limit, offset } = params;\n    this.requireId(userId);\n\n    return this.request<PaginatedResourceResponse<OrganizationMembership[]>>({\n      method: 'GET',\n      path: joinPaths(basePath, userId, 'organization_memberships'),\n      queryParams: { limit, offset },\n    });\n  }\n\n  public async getOrganizationInvitationList(params: GetOrganizationInvitationListParams) {\n    const { userId, ...queryParams } = params;\n    this.requireId(userId);\n\n    return this.request<PaginatedResourceResponse<OrganizationInvitation[]>>({\n      method: 'GET',\n      path: joinPaths(basePath, userId, 'organization_invitations'),\n      queryParams,\n    });\n  }\n\n  public async verifyPassword(params: VerifyPasswordParams) {\n    const { userId, password } = params;\n    this.requireId(userId);\n\n    return this.request<{ verified: true }>({\n      method: 'POST',\n      path: joinPaths(basePath, userId, 'verify_password'),\n      bodyParams: { password },\n    });\n  }\n\n  public async verifyTOTP(params: VerifyTOTPParams) {\n    const { userId, code } = params;\n    this.requireId(userId);\n\n    return this.request<{ verified: true; code_type: 'totp' }>({\n      method: 'POST',\n      path: joinPaths(basePath, userId, 'verify_totp'),\n      bodyParams: { code },\n    });\n  }\n\n  public async banUser(userId: string) {\n    this.requireId(userId);\n    return this.request<User>({\n      method: 'POST',\n      path: joinPaths(basePath, userId, 'ban'),\n    });\n  }\n\n  public async unbanUser(userId: string) {\n    this.requireId(userId);\n    return this.request<User>({\n      method: 'POST',\n      path: joinPaths(basePath, userId, 'unban'),\n    });\n  }\n\n  public async lockUser(userId: string) {\n    this.requireId(userId);\n    return this.request<User>({\n      method: 'POST',\n      path: joinPaths(basePath, userId, 'lock'),\n    });\n  }\n\n  public async unlockUser(userId: string) {\n    this.requireId(userId);\n    return this.request<User>({\n      method: 'POST',\n      path: joinPaths(basePath, userId, 'unlock'),\n    });\n  }\n\n  public async deleteUserProfileImage(userId: string) {\n    this.requireId(userId);\n    return this.request<User>({\n      method: 'DELETE',\n      path: joinPaths(basePath, userId, 'profile_image'),\n    });\n  }\n\n  public async deleteUserPasskey(params: DeleteUserPasskeyParams) {\n    this.requireId(params.userId);\n    this.requireId(params.passkeyIdentificationId);\n    return this.request<DeletedObject>({\n      method: 'DELETE',\n      path: joinPaths(basePath, params.userId, 'passkeys', params.passkeyIdentificationId),\n    });\n  }\n\n  public async deleteUserWeb3Wallet(params: DeleteWeb3WalletParams) {\n    this.requireId(params.userId);\n    this.requireId(params.web3WalletIdentificationId);\n    return this.request<DeletedObject>({\n      method: 'DELETE',\n      path: joinPaths(basePath, params.userId, 'web3_wallets', params.web3WalletIdentificationId),\n    });\n  }\n\n  public async deleteUserExternalAccount(params: DeleteUserExternalAccountParams) {\n    this.requireId(params.userId);\n    this.requireId(params.externalAccountId);\n    return this.request<DeletedObject>({\n      method: 'DELETE',\n      path: joinPaths(basePath, params.userId, 'external_accounts', params.externalAccountId),\n    });\n  }\n\n  public async deleteUserBackupCodes(userId: string) {\n    this.requireId(userId);\n    return this.request<UserID>({\n      method: 'DELETE',\n      path: joinPaths(basePath, userId, 'backup_code'),\n    });\n  }\n\n  public async deleteUserTOTP(userId: string) {\n    this.requireId(userId);\n    return this.request<UserID>({\n      method: 'DELETE',\n      path: joinPaths(basePath, userId, 'totp'),\n    });\n  }\n}\n","import type { ClerkPaginationRequest } from '@clerk/types';\n\nimport type { PaginatedResourceResponse } from '../resources/Deserializer';\nimport type { WaitlistEntryStatus } from '../resources/Enums';\nimport type { WaitlistEntry } from '../resources/WaitlistEntry';\nimport { AbstractAPI } from './AbstractApi';\nimport type { WithSign } from './util-types';\n\nconst basePath = '/waitlist_entries';\n\ntype WaitlistEntryListParams = ClerkPaginationRequest<{\n  /**\n   * Filter waitlist entries by `email_address` or `id`\n   */\n  query?: string;\n  status?: WaitlistEntryStatus;\n  orderBy?: WithSign<'created_at' | 'invited_at' | 'email_address'>;\n}>;\n\ntype WaitlistEntryCreateParams = {\n  emailAddress: string;\n  notify?: boolean;\n};\n\nexport class WaitlistEntryAPI extends AbstractAPI {\n  public async list(params: WaitlistEntryListParams = {}) {\n    return this.request<PaginatedResourceResponse<WaitlistEntry>>({\n      method: 'GET',\n      path: basePath,\n      queryParams: params,\n    });\n  }\n\n  public async create(params: WaitlistEntryCreateParams) {\n    return this.request<WaitlistEntry>({\n      method: 'POST',\n      path: basePath,\n      bodyParams: params,\n    });\n  }\n}\n","import { joinPaths } from '../../util/path';\nimport type { WebhooksSvixJSON } from '../resources/JSON';\nimport { AbstractAPI } from './AbstractApi';\n\nconst basePath = '/webhooks';\n\nexport class WebhookAPI extends AbstractAPI {\n  public async createSvixApp() {\n    return this.request<WebhooksSvixJSON>({\n      method: 'POST',\n      path: joinPaths(basePath, 'svix'),\n    });\n  }\n\n  public async generateSvixAuthURL() {\n    return this.request<WebhooksSvixJSON>({\n      method: 'POST',\n      path: joinPaths(basePath, 'svix_url'),\n    });\n  }\n\n  public async deleteSvixApp() {\n    return this.request<void>({\n      method: 'DELETE',\n      path: joinPaths(basePath, 'svix'),\n    });\n  }\n}\n","import { ClerkAPIResponseError, parseError } from '@clerk/shared/error';\nimport type { ClerkAPIError, ClerkAPIErrorJSON } from '@clerk/types';\nimport snakecaseKeys from 'snakecase-keys';\n\nimport { API_URL, API_VERSION, constants, SUPPORTED_BAPI_VERSION, USER_AGENT } from '../constants';\nimport { runtime } from '../runtime';\nimport { assertValidSecretKey } from '../util/optionsAssertions';\nimport { joinPaths } from '../util/path';\nimport { deserialize } from './resources/Deserializer';\n\nexport type ClerkBackendApiRequestOptions = {\n  method: 'GET' | 'POST' | 'PATCH' | 'DELETE' | 'PUT';\n  queryParams?: Record<string, unknown>;\n  headerParams?: Record<string, string>;\n  bodyParams?: Record<string, unknown> | Array<Record<string, unknown>>;\n  formData?: FormData;\n} & (\n  | {\n      url: string;\n      path?: string;\n    }\n  | {\n      url?: string;\n      path: string;\n    }\n);\n\nexport type ClerkBackendApiResponse<T> =\n  | {\n      data: T;\n      errors: null;\n      totalCount?: number;\n    }\n  | {\n      data: null;\n      errors: ClerkAPIError[];\n      totalCount?: never;\n      clerkTraceId?: string;\n      status?: number;\n      statusText?: string;\n      retryAfter?: number;\n    };\n\nexport type RequestFunction = ReturnType<typeof buildRequest>;\n\ntype BuildRequestOptions = {\n  /* Secret Key */\n  secretKey?: string;\n  /* Backend API URL */\n  apiUrl?: string;\n  /* Backend API version */\n  apiVersion?: string;\n  /* Library/SDK name */\n  userAgent?: string;\n  /**\n   * Allow requests without specifying a secret key. In most cases this should be set to `false`.\n   * @default true\n   */\n  requireSecretKey?: boolean;\n};\n\nexport function buildRequest(options: BuildRequestOptions) {\n  const requestFn = async <T>(requestOptions: ClerkBackendApiRequestOptions): Promise<ClerkBackendApiResponse<T>> => {\n    const {\n      secretKey,\n      requireSecretKey = true,\n      apiUrl = API_URL,\n      apiVersion = API_VERSION,\n      userAgent = USER_AGENT,\n    } = options;\n    const { path, method, queryParams, headerParams, bodyParams, formData } = requestOptions;\n\n    if (requireSecretKey) {\n      assertValidSecretKey(secretKey);\n    }\n\n    const url = joinPaths(apiUrl, apiVersion, path);\n\n    // Build final URL with search parameters\n    const finalUrl = new URL(url);\n\n    if (queryParams) {\n      // Snakecase query parameters\n      const snakecasedQueryParams = snakecaseKeys({ ...queryParams });\n\n      // Support array values for queryParams such as { foo: [42, 43] }\n      for (const [key, val] of Object.entries(snakecasedQueryParams)) {\n        if (val) {\n          [val].flat().forEach(v => finalUrl.searchParams.append(key, v as string));\n        }\n      }\n    }\n\n    // Build headers\n    const headers: Record<string, any> = {\n      'Clerk-API-Version': SUPPORTED_BAPI_VERSION,\n      'User-Agent': userAgent,\n      ...headerParams,\n    };\n\n    if (secretKey) {\n      headers.Authorization = `Bearer ${secretKey}`;\n    }\n\n    let res: Response | undefined;\n    try {\n      if (formData) {\n        res = await runtime.fetch(finalUrl.href, {\n          method,\n          headers,\n          body: formData,\n        });\n      } else {\n        // Enforce application/json for all non form-data requests\n        headers['Content-Type'] = 'application/json';\n\n        const buildBody = () => {\n          const hasBody = method !== 'GET' && bodyParams && Object.keys(bodyParams).length > 0;\n          if (!hasBody) {\n            return null;\n          }\n\n          const formatKeys = (object: Parameters<typeof snakecaseKeys>[0]) => snakecaseKeys(object, { deep: false });\n\n          return {\n            body: JSON.stringify(Array.isArray(bodyParams) ? bodyParams.map(formatKeys) : formatKeys(bodyParams)),\n          };\n        };\n\n        res = await runtime.fetch(finalUrl.href, {\n          method,\n          headers,\n          ...buildBody(),\n        });\n      }\n\n      // TODO: Parse JSON or Text response based on a response header\n      const isJSONResponse =\n        res?.headers && res.headers?.get(constants.Headers.ContentType) === constants.ContentTypes.Json;\n      const responseBody = await (isJSONResponse ? res.json() : res.text());\n\n      if (!res.ok) {\n        return {\n          data: null,\n          errors: parseErrors(responseBody),\n          status: res?.status,\n          statusText: res?.statusText,\n          clerkTraceId: getTraceId(responseBody, res?.headers),\n          retryAfter: getRetryAfter(res?.headers),\n        };\n      }\n\n      return {\n        ...deserialize<T>(responseBody),\n        errors: null,\n      };\n    } catch (err) {\n      if (err instanceof Error) {\n        return {\n          data: null,\n          errors: [\n            {\n              code: 'unexpected_error',\n              message: err.message || 'Unexpected error',\n            },\n          ],\n          clerkTraceId: getTraceId(err, res?.headers),\n        };\n      }\n\n      return {\n        data: null,\n        errors: parseErrors(err),\n        status: res?.status,\n        statusText: res?.statusText,\n        clerkTraceId: getTraceId(err, res?.headers),\n        retryAfter: getRetryAfter(res?.headers),\n      };\n    }\n  };\n\n  return withLegacyRequestReturn(requestFn);\n}\n\n// Returns either clerk_trace_id if present in response json, otherwise defaults to CF-Ray header\n// If the request failed before receiving a response, returns undefined\nfunction getTraceId(data: unknown, headers?: Headers): string {\n  if (data && typeof data === 'object' && 'clerk_trace_id' in data && typeof data.clerk_trace_id === 'string') {\n    return data.clerk_trace_id;\n  }\n\n  const cfRay = headers?.get('cf-ray');\n  return cfRay || '';\n}\n\nfunction getRetryAfter(headers?: Headers): number | undefined {\n  const retryAfter = headers?.get('Retry-After');\n  if (!retryAfter) return;\n\n  const value = parseInt(retryAfter, 10);\n  if (isNaN(value)) return;\n\n  return value;\n}\n\nfunction parseErrors(data: unknown): ClerkAPIError[] {\n  if (!!data && typeof data === 'object' && 'errors' in data) {\n    const errors = data.errors as ClerkAPIErrorJSON[];\n    return errors.length > 0 ? errors.map(parseError) : [];\n  }\n  return [];\n}\n\ntype LegacyRequestFunction = <T>(requestOptions: ClerkBackendApiRequestOptions) => Promise<T>;\n\n// TODO(dimkl): Will be probably be dropped in next major version\nfunction withLegacyRequestReturn(cb: any): LegacyRequestFunction {\n  return async (...args) => {\n    const { data, errors, totalCount, status, statusText, clerkTraceId, retryAfter } = await cb(...args);\n    if (errors) {\n      // instead of passing `data: errors`, we have set the `error.errors` because\n      // the errors returned from callback is already parsed and passing them as `data`\n      // will not be able to assign them to the instance\n      const error = new ClerkAPIResponseError(statusText || '', {\n        data: [],\n        status,\n        clerkTraceId,\n        retryAfter,\n      });\n      error.errors = errors;\n      throw error;\n    }\n\n    if (typeof totalCount !== 'undefined') {\n      return { data, totalCount };\n    }\n\n    return data;\n  };\n}\n","import type { ActorTokenStatus } from './Enums';\nimport type { ActorTokenJSON } from './JSON';\n\nexport class ActorToken {\n  constructor(\n    readonly id: string,\n    readonly status: ActorTokenStatus,\n    readonly userId: string,\n    readonly actor: Record<string, unknown> | null,\n    readonly token: string | null | undefined,\n    readonly url: string | null | undefined,\n    readonly createdAt: number,\n    readonly updatedAt: number,\n  ) {}\n\n  static fromJSON(data: ActorTokenJSON): ActorToken {\n    return new ActorToken(\n      data.id,\n      data.status,\n      data.user_id,\n      data.actor,\n      data.token,\n      data.url,\n      data.created_at,\n      data.updated_at,\n    );\n  }\n}\n","import type { AccountlessApplicationJSON } from './JSON';\n\nexport class AccountlessApplication {\n  constructor(\n    readonly publishableKey: string,\n    readonly secretKey: string,\n    readonly claimUrl: string,\n    readonly apiKeysUrl: string,\n  ) {}\n\n  static fromJSON(data: AccountlessApplicationJSON): AccountlessApplication {\n    return new AccountlessApplication(data.publishable_key, data.secret_key, data.claim_url, data.api_keys_url);\n  }\n}\n","import type { AllowlistIdentifierType } from './Enums';\nimport type { AllowlistIdentifierJSON } from './JSON';\n\nexport class AllowlistIdentifier {\n  constructor(\n    readonly id: string,\n    readonly identifier: string,\n    readonly identifierType: AllowlistIdentifierType,\n    readonly createdAt: number,\n    readonly updatedAt: number,\n    readonly instanceId?: string,\n    readonly invitationId?: string,\n  ) {}\n\n  static fromJSON(data: AllowlistIdentifierJSON): AllowlistIdentifier {\n    return new AllowlistIdentifier(\n      data.id,\n      data.identifier,\n      data.identifier_type,\n      data.created_at,\n      data.updated_at,\n      data.instance_id,\n      data.invitation_id,\n    );\n  }\n}\n","import type { BlocklistIdentifierType } from './Enums';\nimport type { BlocklistIdentifierJSON } from './JSON';\n\nexport class BlocklistIdentifier {\n  constructor(\n    readonly id: string,\n    readonly identifier: string,\n    readonly identifierType: BlocklistIdentifierType,\n    readonly createdAt: number,\n    readonly updatedAt: number,\n    readonly instanceId?: string,\n  ) {}\n\n  static fromJSON(data: BlocklistIdentifierJSON): BlocklistIdentifier {\n    return new BlocklistIdentifier(\n      data.id,\n      data.identifier,\n      data.identifier_type,\n      data.created_at,\n      data.updated_at,\n      data.instance_id,\n    );\n  }\n}\n","import type { SessionActivityJSON, SessionJSON } from './JSON';\n\nexport class SessionActivity {\n  constructor(\n    readonly id: string,\n    readonly isMobile: boolean,\n    readonly ipAddress?: string,\n    readonly city?: string,\n    readonly country?: string,\n    readonly browserVersion?: string,\n    readonly browserName?: string,\n    readonly deviceType?: string,\n  ) {}\n\n  static fromJSON(data: SessionActivityJSON): SessionActivity {\n    return new SessionActivity(\n      data.id,\n      data.is_mobile,\n      data.ip_address,\n      data.city,\n      data.country,\n      data.browser_version,\n      data.browser_name,\n      data.device_type,\n    );\n  }\n}\n\nexport class Session {\n  constructor(\n    readonly id: string,\n    readonly clientId: string,\n    readonly userId: string,\n    readonly status: string,\n    readonly lastActiveAt: number,\n    readonly expireAt: number,\n    readonly abandonAt: number,\n    readonly createdAt: number,\n    readonly updatedAt: number,\n    readonly lastActiveOrganizationId?: string,\n    readonly latestActivity?: SessionActivity,\n    readonly actor: Record<string, unknown> | null = null,\n  ) {}\n\n  static fromJSON(data: SessionJSON): Session {\n    return new Session(\n      data.id,\n      data.client_id,\n      data.user_id,\n      data.status,\n      data.last_active_at,\n      data.expire_at,\n      data.abandon_at,\n      data.created_at,\n      data.updated_at,\n      data.last_active_organization_id,\n      data.latest_activity && SessionActivity.fromJSON(data.latest_activity),\n      data.actor,\n    );\n  }\n}\n","import type { ClientJSON } from './JSON';\nimport { Session } from './Session';\n\nexport class Client {\n  constructor(\n    readonly id: string,\n    readonly sessionIds: string[],\n    readonly sessions: Session[],\n    readonly signInId: string | null,\n    readonly signUpId: string | null,\n    readonly lastActiveSessionId: string | null,\n    readonly createdAt: number,\n    readonly updatedAt: number,\n  ) {}\n\n  static fromJSON(data: ClientJSON): Client {\n    return new Client(\n      data.id,\n      data.session_ids,\n      data.sessions.map(x => Session.fromJSON(x)),\n      data.sign_in_id,\n      data.sign_up_id,\n      data.last_active_session_id,\n      data.created_at,\n      data.updated_at,\n    );\n  }\n}\n","import type { CnameTargetJSON } from './JSON';\n\nexport class CnameTarget {\n  constructor(\n    readonly host: string,\n    readonly value: string,\n    readonly required: boolean,\n  ) {}\n\n  static fromJSON(data: CnameTargetJSON): CnameTarget {\n    return new CnameTarget(data.host, data.value, data.required);\n  }\n}\n","import type { CookiesJSON } from './JSON';\n\nexport class Cookies {\n  constructor(readonly cookies: string[]) {}\n\n  static fromJSON(data: CookiesJSON): Cookies {\n    return new Cookies(data.cookies);\n  }\n}\n","import type { DeletedObjectJSON } from './JSON';\n\nexport class DeletedObject {\n  constructor(\n    readonly object: string,\n    readonly id: string | null,\n    readonly slug: string | null,\n    readonly deleted: boolean,\n  ) {}\n\n  static fromJSON(data: DeletedObjectJSON) {\n    return new DeletedObject(data.object, data.id || null, data.slug || null, data.deleted);\n  }\n}\n","import { CnameTarget } from './CnameTarget';\nimport type { DomainJSON } from './JSON';\n\nexport class Domain {\n  constructor(\n    readonly id: string,\n    readonly name: string,\n    readonly isSatellite: boolean,\n    readonly frontendApiUrl: string,\n    readonly developmentOrigin: string,\n    readonly cnameTargets: CnameTarget[],\n    readonly accountsPortalUrl?: string | null,\n    readonly proxyUrl?: string | null,\n  ) {}\n\n  static fromJSON(data: DomainJSON): Domain {\n    return new Domain(\n      data.id,\n      data.name,\n      data.is_satellite,\n      data.frontend_api_url,\n      data.development_origin,\n      data.cname_targets && data.cname_targets.map(x => CnameTarget.fromJSON(x)),\n      data.accounts_portal_url,\n      data.proxy_url,\n    );\n  }\n}\n","import type { EmailJSON } from './JSON';\n\nexport class Email {\n  constructor(\n    readonly id: string,\n    readonly fromEmailName: string,\n    readonly emailAddressId: string | null,\n    readonly toEmailAddress?: string,\n    readonly subject?: string,\n    readonly body?: string,\n    readonly bodyPlain?: string | null,\n    readonly status?: string,\n    readonly slug?: string | null,\n    readonly data?: Record<string, any> | null,\n    readonly deliveredByClerk?: boolean,\n  ) {}\n\n  static fromJSON(data: EmailJSON): Email {\n    return new Email(\n      data.id,\n      data.from_email_name,\n      data.email_address_id,\n      data.to_email_address,\n      data.subject,\n      data.body,\n      data.body_plain,\n      data.status,\n      data.slug,\n      data.data,\n      data.delivered_by_clerk,\n    );\n  }\n}\n","import type { IdentificationLinkJSON } from './JSON';\n\nexport class IdentificationLink {\n  constructor(\n    readonly id: string,\n    readonly type: string,\n  ) {}\n\n  static fromJSON(data: IdentificationLinkJSON): IdentificationLink {\n    return new IdentificationLink(data.id, data.type);\n  }\n}\n","import type { OrganizationDomainVerificationJSON, VerificationJSON } from './JSON';\n\nexport class Verification {\n  constructor(\n    readonly status: string,\n    readonly strategy: string,\n    readonly externalVerificationRedirectURL: URL | null = null,\n    readonly attempts: number | null = null,\n    readonly expireAt: number | null = null,\n    readonly nonce: string | null = null,\n    readonly message: string | null = null,\n  ) {}\n\n  static fromJSON(data: VerificationJSON): Verification {\n    return new Verification(\n      data.status,\n      data.strategy,\n      data.external_verification_redirect_url ? new URL(data.external_verification_redirect_url) : null,\n      data.attempts,\n      data.expire_at,\n      data.nonce,\n    );\n  }\n}\n\nexport class OrganizationDomainVerification {\n  constructor(\n    readonly status: string,\n    readonly strategy: string,\n    readonly attempts: number | null = null,\n    readonly expireAt: number | null = null,\n  ) {}\n\n  static fromJSON(data: OrganizationDomainVerificationJSON): OrganizationDomainVerification {\n    return new OrganizationDomainVerification(data.status, data.strategy, data.attempts, data.expires_at);\n  }\n}\n","import { IdentificationLink } from './IdentificationLink';\nimport type { EmailAddressJSON } from './JSON';\nimport { Verification } from './Verification';\n\nexport class EmailAddress {\n  constructor(\n    readonly id: string,\n    readonly emailAddress: string,\n    readonly verification: Verification | null,\n    readonly linkedTo: IdentificationLink[],\n  ) {}\n\n  static fromJSON(data: EmailAddressJSON): EmailAddress {\n    return new EmailAddress(\n      data.id,\n      data.email_address,\n      data.verification && Verification.fromJSON(data.verification),\n      data.linked_to.map(link => IdentificationLink.fromJSON(link)),\n    );\n  }\n}\n","import type { ExternalAccountJSON } from './JSON';\nimport { Verification } from './Verification';\n\nexport class ExternalAccount {\n  constructor(\n    readonly id: string,\n    readonly provider: string,\n    readonly identificationId: string,\n    readonly externalId: string,\n    readonly approvedScopes: string,\n    readonly emailAddress: string,\n    readonly firstName: string,\n    readonly lastName: string,\n    readonly imageUrl: string,\n    readonly username: string | null,\n    readonly phoneNumber: string | null,\n    readonly publicMetadata: Record<string, unknown> | null = {},\n    readonly label: string | null,\n    readonly verification: Verification | null,\n  ) {}\n\n  static fromJSON(data: ExternalAccountJSON): ExternalAccount {\n    return new ExternalAccount(\n      data.id,\n      data.provider,\n      data.identification_id,\n      data.provider_user_id,\n      data.approved_scopes,\n      data.email_address,\n      data.first_name,\n      data.last_name,\n      data.image_url || '',\n      data.username,\n      data.phone_number,\n      data.public_metadata,\n      data.label,\n      data.verification && Verification.fromJSON(data.verification),\n    );\n  }\n}\n","import type { InstanceJSON } from './JSON';\n\nexport class Instance {\n  constructor(\n    readonly id: string,\n    readonly environmentType: string,\n    readonly allowedOrigins: Array<string> | null,\n  ) {}\n\n  static fromJSON(data: InstanceJSON): Instance {\n    return new Instance(data.id, data.environment_type, data.allowed_origins);\n  }\n}\n","import type { InstanceRestrictionsJSON } from './JSON';\n\nexport class InstanceRestrictions {\n  constructor(\n    readonly allowlist: boolean,\n    readonly blocklist: boolean,\n    readonly blockEmailSubaddresses: boolean,\n    readonly blockDisposableEmailDomains: boolean,\n    readonly ignoreDotsForGmailAddresses: boolean,\n  ) {}\n\n  static fromJSON(data: InstanceRestrictionsJSON): InstanceRestrictions {\n    return new InstanceRestrictions(\n      data.allowlist,\n      data.blocklist,\n      data.block_email_subaddresses,\n      data.block_disposable_email_domains,\n      data.ignore_dots_for_gmail_addresses,\n    );\n  }\n}\n","import type { InstanceSettingsJSON } from './JSON';\n\nexport class InstanceSettings {\n  constructor(\n    readonly id?: string | undefined,\n    readonly restrictedToAllowlist?: boolean | undefined,\n    readonly fromEmailAddress?: string | undefined,\n    readonly progressiveSignUp?: boolean | undefined,\n    readonly enhancedEmailDeliverability?: boolean | undefined,\n  ) {}\n\n  static fromJSON(data: InstanceSettingsJSON): InstanceSettings {\n    return new InstanceSettings(\n      data.id,\n      data.restricted_to_allowlist,\n      data.from_email_address,\n      data.progressive_sign_up,\n      data.enhanced_email_deliverability,\n    );\n  }\n}\n","import type { InvitationStatus } from './Enums';\nimport type { InvitationJSON } from './JSON';\n\nexport class Invitation {\n  private _raw: InvitationJSON | null = null;\n\n  public get raw(): InvitationJSON | null {\n    return this._raw;\n  }\n\n  constructor(\n    readonly id: string,\n    readonly emailAddress: string,\n    readonly publicMetadata: Record<string, unknown> | null,\n    readonly createdAt: number,\n    readonly updatedAt: number,\n    readonly status: InvitationStatus,\n    readonly url?: string,\n    readonly revoked?: boolean,\n  ) {}\n\n  static fromJSON(data: InvitationJSON): Invitation {\n    const res = new Invitation(\n      data.id,\n      data.email_address,\n      data.public_metadata,\n      data.created_at,\n      data.updated_at,\n      data.status,\n      data.url,\n      data.revoked,\n    );\n    res._raw = data;\n    return res;\n  }\n}\n","import type { SignUpStatus } from '@clerk/types';\n\nimport type {\n  ActorTokenStatus,\n  AllowlistIdentifierType,\n  BlocklistIdentifierType,\n  DomainsEnrollmentModes,\n  InvitationStatus,\n  OrganizationDomainVerificationStatus,\n  OrganizationDomainVerificationStrategy,\n  OrganizationEnrollmentMode,\n  OrganizationInvitationStatus,\n  OrganizationMembershipRole,\n  SignInStatus,\n  SignUpVerificationNextAction,\n  WaitlistEntryStatus,\n} from './Enums';\n\nexport const ObjectType = {\n  AccountlessApplication: 'accountless_application',\n  ActorToken: 'actor_token',\n  AllowlistIdentifier: 'allowlist_identifier',\n  BlocklistIdentifier: 'blocklist_identifier',\n  Client: 'client',\n  Cookies: 'cookies',\n  Domain: 'domain',\n  Email: 'email',\n  EmailAddress: 'email_address',\n  ExternalAccount: 'external_account',\n  FacebookAccount: 'facebook_account',\n  GoogleAccount: 'google_account',\n  Instance: 'instance',\n  InstanceRestrictions: 'instance_restrictions',\n  InstanceSettings: 'instance_settings',\n  Invitation: 'invitation',\n  JwtTemplate: 'jwt_template',\n  OauthAccessToken: 'oauth_access_token',\n  OAuthApplication: 'oauth_application',\n  Organization: 'organization',\n  OrganizationDomain: 'organization_domain',\n  OrganizationInvitation: 'organization_invitation',\n  OrganizationMembership: 'organization_membership',\n  OrganizationSettings: 'organization_settings',\n  PhoneNumber: 'phone_number',\n  ProxyCheck: 'proxy_check',\n  RedirectUrl: 'redirect_url',\n  SamlAccount: 'saml_account',\n  SamlConnection: 'saml_connection',\n  Session: 'session',\n  SignInAttempt: 'sign_in_attempt',\n  SignInToken: 'sign_in_token',\n  SignUpAttempt: 'sign_up_attempt',\n  SmsMessage: 'sms_message',\n  User: 'user',\n  WaitlistEntry: 'waitlist_entry',\n  Web3Wallet: 'web3_wallet',\n  Token: 'token',\n  TotalCount: 'total_count',\n  TestingToken: 'testing_token',\n  Role: 'role',\n  Permission: 'permission',\n} as const;\n\nexport type ObjectType = (typeof ObjectType)[keyof typeof ObjectType];\n\nexport interface ClerkResourceJSON {\n  object: ObjectType;\n  id: string;\n}\n\nexport interface CookiesJSON {\n  object: typeof ObjectType.Cookies;\n  cookies: string[];\n}\n\nexport interface TokenJSON {\n  object: typeof ObjectType.Token;\n  jwt: string;\n}\n\nexport interface AccountlessApplicationJSON extends ClerkResourceJSON {\n  object: typeof ObjectType.AccountlessApplication;\n  publishable_key: string;\n  secret_key: string;\n  claim_url: string;\n  api_keys_url